diff --git a/modules/juce_audio_plugin_client/VST/juce_VST_Wrapper.cpp b/modules/juce_audio_plugin_client/VST/juce_VST_Wrapper.cpp
index c87b97d49..159ab0c7c 100644
--- a/modules/juce_audio_plugin_client/VST/juce_VST_Wrapper.cpp
+++ b/modules/juce_audio_plugin_client/VST/juce_VST_Wrapper.cpp
@@ -71,14 +71,7 @@ JUCE_BEGIN_IGNORE_WARNINGS_MSVC (4458)
 
 namespace Vst2
 {
-// If the following files cannot be found then you are probably trying to build
-// a VST2 plug-in or a VST2-compatible VST3 plug-in. To do this you must have a
-// VST2 SDK in your header search paths or use the "VST (Legacy) SDK Folder"
-// field in the Projucer. The VST2 SDK can be obtained from the
-// vstsdk3610_11_06_2018_build_37 (or older) VST3 SDK or JUCE version 5.3.2. You
-// also need a VST2 license from Steinberg to distribute VST2 plug-ins.
-#include "pluginterfaces/vst2.x/aeffect.h"
-#include "pluginterfaces/vst2.x/aeffectx.h"
+#include "../../juce_audio_processors/format_types/juce_VSTInterface.h"
 }
 
 JUCE_END_IGNORE_WARNINGS_MSVC
@@ -89,7 +82,6 @@ JUCE_END_IGNORE_WARNINGS_GCC_LIKE
  #pragma pack (push, 8)
 #endif
 
-#define JUCE_VSTINTERFACE_H_INCLUDED 1
 #define JUCE_GUI_BASICS_INCLUDE_XHEADERS 1
 
 #include "../utility/juce_IncludeModuleHeaders.h"
@@ -286,7 +278,7 @@ private:
 
 public:
     //==============================================================================
-    JuceVSTWrapper (Vst2::audioMasterCallback cb, AudioProcessor* af)
+    JuceVSTWrapper (Vst2::VstHostCallback cb, AudioProcessor* af)
        : hostCallback (cb),
          processor (af)
     {
@@ -314,41 +306,41 @@ public:
         juceParameters.update (*processor, false);
 
         memset (&vstEffect, 0, sizeof (vstEffect));
-        vstEffect.magic = 0x56737450 /* 'VstP' */;
-        vstEffect.dispatcher = (Vst2::AEffectDispatcherProc) dispatcherCB;
-        vstEffect.process = nullptr;
-        vstEffect.setParameter = (Vst2::AEffectSetParameterProc) setParameterCB;
-        vstEffect.getParameter = (Vst2::AEffectGetParameterProc) getParameterCB;
+        vstEffect.interfaceIdentifier = Vst2::juceVstInterfaceIdentifier;
+        vstEffect.dispatchFunction = dispatcherCB;
+        vstEffect.processAudioFunction = nullptr;
+        vstEffect.setParameterValueFunction = setParameterCB;
+        vstEffect.getParameterValueFunction = getParameterCB;
         vstEffect.numPrograms = jmax (1, af->getNumPrograms());
-        vstEffect.numParams = juceParameters.getNumParameters();
-        vstEffect.numInputs = maxNumInChannels;
-        vstEffect.numOutputs = maxNumOutChannels;
-        vstEffect.initialDelay = processor->getLatencySamples();
-        vstEffect.object = this;
-        vstEffect.uniqueID = JucePlugin_VSTUniqueID;
+        vstEffect.numParameters = juceParameters.getNumParameters();
+        vstEffect.numInputChannels = maxNumInChannels;
+        vstEffect.numOutputChannels = maxNumOutChannels;
+        vstEffect.latency = processor->getLatencySamples();
+        vstEffect.effectPointer = this;
+        vstEffect.plugInIdentifier = JucePlugin_VSTUniqueID;
 
        #ifdef JucePlugin_VSTChunkStructureVersion
-        vstEffect.version = JucePlugin_VSTChunkStructureVersion;
+        vstEffect.plugInVersion = JucePlugin_VSTChunkStructureVersion;
        #else
-        vstEffect.version = JucePlugin_VersionCode;
+        vstEffect.plugInVersion = JucePlugin_VersionCode;
        #endif
 
-        vstEffect.processReplacing = (Vst2::AEffectProcessProc) processReplacingCB;
-        vstEffect.processDoubleReplacing = (Vst2::AEffectProcessDoubleProc) processDoubleReplacingCB;
+        vstEffect.processAudioInplaceFunction = processReplacingCB;
+        vstEffect.processDoubleAudioInplaceFunction = processDoubleReplacingCB;
 
-        vstEffect.flags |= Vst2::effFlagsHasEditor;
+        vstEffect.flags |= Vst2::vstEffectFlagHasEditor;
 
-        vstEffect.flags |= Vst2::effFlagsCanReplacing;
+        vstEffect.flags |= Vst2::vstEffectFlagInplaceAudio;
         if (processor->supportsDoublePrecisionProcessing())
-            vstEffect.flags |= Vst2::effFlagsCanDoubleReplacing;
+            vstEffect.flags |= Vst2::vstEffectFlagInplaceDoubleAudio;
 
-        vstEffect.flags |= Vst2::effFlagsProgramChunks;
+        vstEffect.flags |= Vst2::vstEffectFlagDataInChunks;
 
        #if JucePlugin_IsSynth
-        vstEffect.flags |= Vst2::effFlagsIsSynth;
+        vstEffect.flags |= Vst2::vstEffectFlagIsSynth;
        #else
         if (processor->getTailLengthSeconds() == 0.0)
-            vstEffect.flags |= Vst2::effFlagsNoSoundInStop;
+            vstEffect.flags |= 512;
        #endif
 
         activePlugins.add (this);
@@ -392,7 +384,7 @@ public:
         }
     }
 
-    Vst2::AEffect* getAEffect() noexcept    { return &vstEffect; }
+    Vst2::VstEffectInterface* getAEffect() noexcept    { return &vstEffect; }
 
     template <typename FloatType>
     void internalProcessReplacing (FloatType** inputs, FloatType** outputs,
@@ -527,7 +519,7 @@ public:
 
             // Send VST events to the host.
             if (hostCallback != nullptr)
-                hostCallback (&vstEffect, Vst2::audioMasterProcessEvents, 0, 0, outgoingEvents.events, 0);
+                hostCallback (&vstEffect, Vst2::hostOpcodePreAudioProcessingEvents, 0, 0, outgoingEvents.events, 0);
            #elif JUCE_DEBUG
             /*  This assertion is caused when you've added some events to the
                 midiMessages array in your processBlock() method, which usually means
@@ -556,7 +548,7 @@ public:
         internalProcessReplacing (inputs, outputs, sampleFrames, floatTempBuffers);
     }
 
-    static void processReplacingCB (Vst2::AEffect* vstInterface, float** inputs, float** outputs, int32 sampleFrames)
+    static void processReplacingCB (Vst2::VstEffectInterface* vstInterface, float** inputs, float** outputs, int32 sampleFrames)
     {
         getWrapper (vstInterface)->processReplacing (inputs, outputs, sampleFrames);
     }
@@ -567,7 +559,7 @@ public:
         internalProcessReplacing (inputs, outputs, sampleFrames, doubleTempBuffers);
     }
 
-    static void processDoubleReplacingCB (Vst2::AEffect* vstInterface, double** inputs, double** outputs, int32 sampleFrames)
+    static void processDoubleReplacingCB (Vst2::VstEffectInterface* vstInterface, double** inputs, double** outputs, int32 sampleFrames)
     {
         getWrapper (vstInterface)->processDoubleReplacing (inputs, outputs, sampleFrames);
     }
@@ -579,7 +571,7 @@ public:
         {
             isProcessing = true;
 
-            auto numInAndOutChannels = static_cast<size_t> (vstEffect.numInputs + vstEffect.numOutputs);
+            auto numInAndOutChannels = static_cast<size_t> (vstEffect.numInputChannels + vstEffect.numOutputChannels);
             floatTempBuffers .channels.calloc (numInAndOutChannels);
             doubleTempBuffers.channels.calloc (numInAndOutChannels);
 
@@ -598,16 +590,16 @@ public:
             midiEvents.ensureSize (2048);
             midiEvents.clear();
 
-            vstEffect.initialDelay = processor->getLatencySamples();
+            vstEffect.latency = processor->getLatencySamples();
 
             /** If this plug-in is a synth or it can receive midi events we need to tell the
                 host that we want midi. In the SDK this method is marked as deprecated, but
                 some hosts rely on this behaviour.
             */
-            if (vstEffect.flags & Vst2::effFlagsIsSynth || JucePlugin_WantsMidiInput || JucePlugin_IsMidiEffect)
+            if (vstEffect.flags & Vst2::vstEffectFlagIsSynth || JucePlugin_WantsMidiInput || JucePlugin_IsMidiEffect)
             {
                 if (hostCallback != nullptr)
-                    hostCallback (&vstEffect, Vst2::audioMasterWantMidi, 0, 1, nullptr, 0);
+                    hostCallback (&vstEffect, Vst2::hostOpcodePlugInWantsMidi, 0, 1, nullptr, 0);
             }
 
             if (getHostType().isAbletonLive()
@@ -621,7 +613,7 @@ public:
                 hostCmd.commandSize = sizeof (int);
                 hostCmd.flags = AbletonLiveHostSpecific::KCantBeSuspended;
 
-                hostCallback (&vstEffect, Vst2::audioMasterVendorSpecific, 0, 0, &hostCmd, 0.0f);
+                hostCallback (&vstEffect, Vst2::hostOpcodeManufacturerSpecific, 0, 0, &hostCmd, 0.0f);
             }
 
            #if JucePlugin_ProducesMidiOutput || JucePlugin_IsMidiEffect
@@ -648,28 +640,28 @@ public:
     //==============================================================================
     bool getCurrentPosition (AudioPlayHead::CurrentPositionInfo& info) override
     {
-        const Vst2::VstTimeInfo* ti = nullptr;
+        const Vst2::VstTimingInformation* ti = nullptr;
 
         if (hostCallback != nullptr)
         {
-            int32 flags = Vst2::kVstPpqPosValid  | Vst2::kVstTempoValid
-                        | Vst2::kVstBarsValid    | Vst2::kVstCyclePosValid
-                        | Vst2::kVstTimeSigValid | Vst2::kVstSmpteValid
-                        | Vst2::kVstClockValid;
+            int32 flags = Vst2::vstTimingInfoFlagMusicalPositionValid | Vst2::vstTimingInfoFlagTempoValid
+                              | Vst2::vstTimingInfoFlagLastBarPositionValid | Vst2::vstTimingInfoFlagLoopPositionValid
+                              | Vst2::vstTimingInfoFlagTimeSignatureValid | Vst2::vstTimingInfoFlagSmpteValid
+                              | Vst2::vstTimingInfoFlagNearestClockValid;
 
-            auto result = hostCallback (&vstEffect, Vst2::audioMasterGetTime, 0, flags, nullptr, 0);
-            ti = reinterpret_cast<Vst2::VstTimeInfo*> (result);
+            auto result = hostCallback (&vstEffect, Vst2::hostOpcodeGetTimingInfo, 0, flags, nullptr, 0);
+            ti = reinterpret_cast<Vst2::VstTimingInformation*> (result);
         }
 
         if (ti == nullptr || ti->sampleRate <= 0)
             return false;
 
-        info.bpm = (ti->flags & Vst2::kVstTempoValid) != 0 ? ti->tempo : 0.0;
+        info.bpm = (ti->flags & Vst2::vstTimingInfoFlagTempoValid) != 0 ? ti->tempoBPM : 0.0;
 
-        if ((ti->flags & Vst2::kVstTimeSigValid) != 0)
+        if ((ti->flags & Vst2::vstTimingInfoFlagTimeSignatureValid) != 0)
         {
-            info.timeSigNumerator   = ti->timeSigNumerator;
-            info.timeSigDenominator = ti->timeSigDenominator;
+            info.timeSigNumerator   = ti->timeSignatureNumerator;
+            info.timeSigDenominator = ti->timeSignatureDenominator;
         }
         else
         {
@@ -677,34 +669,34 @@ public:
             info.timeSigDenominator = 4;
         }
 
-        info.timeInSamples = (int64) (ti->samplePos + 0.5);
-        info.timeInSeconds = ti->samplePos / ti->sampleRate;
-        info.ppqPosition = (ti->flags & Vst2::kVstPpqPosValid) != 0 ? ti->ppqPos : 0.0;
-        info.ppqPositionOfLastBarStart = (ti->flags & Vst2::kVstBarsValid) != 0 ? ti->barStartPos : 0.0;
+        info.timeInSamples = (int64) (ti->samplePosition + 0.5);
+        info.timeInSeconds = ti->samplePosition / ti->sampleRate;
+        info.ppqPosition = (ti->flags & Vst2::vstTimingInfoFlagMusicalPositionValid) != 0 ? ti->musicalPosition : 0.0;
+        info.ppqPositionOfLastBarStart = (ti->flags & Vst2::vstTimingInfoFlagLastBarPositionValid) != 0 ? ti->lastBarPosition : 0.0;
 
-        if ((ti->flags & Vst2::kVstSmpteValid) != 0)
+        if ((ti->flags & Vst2::vstTimingInfoFlagSmpteValid) != 0)
         {
             AudioPlayHead::FrameRateType rate = AudioPlayHead::fpsUnknown;
             double fps = 1.0;
 
-            switch (ti->smpteFrameRate)
+            switch (ti->smpteRate)
             {
-                case Vst2::kVstSmpte239fps:       rate = AudioPlayHead::fps23976;    fps = 24.0 * 1000.0 / 1001.0; break;
-                case Vst2::kVstSmpte24fps:        rate = AudioPlayHead::fps24;       fps = 24.0;  break;
-                case Vst2::kVstSmpte25fps:        rate = AudioPlayHead::fps25;       fps = 25.0;  break;
-                case Vst2::kVstSmpte2997fps:      rate = AudioPlayHead::fps2997;     fps = 30.0 * 1000.0 / 1001.0; break;
-                case Vst2::kVstSmpte30fps:        rate = AudioPlayHead::fps30;       fps = 30.0;  break;
-                case Vst2::kVstSmpte2997dfps:     rate = AudioPlayHead::fps2997drop; fps = 30.0 * 1000.0 / 1001.0; break;
-                case Vst2::kVstSmpte30dfps:       rate = AudioPlayHead::fps30drop;   fps = 30.0;  break;
-
-                case Vst2::kVstSmpteFilm16mm:
-                case Vst2::kVstSmpteFilm35mm:     fps = 24.0; break;
-
-                case Vst2::kVstSmpte249fps:       fps = 25.0 * 1000.0 / 1001.0; break;
-                case Vst2::kVstSmpte599fps:       fps = 60.0 * 1000.0 / 1001.0; break;
-                case Vst2::kVstSmpte60fps:        fps = 60; break;
-
-                default:                          jassertfalse; // unknown frame-rate..
+                case Vst2::vstSmpteRateFps239:       rate = AudioPlayHead::fps23976;    fps = 24.0 * 1000.0 / 1001.0; break;
+                case Vst2::vstSmpteRateFps24:        rate = AudioPlayHead::fps24;       fps = 24.0;  break;
+                case Vst2::vstSmpteRateFps25:        rate = AudioPlayHead::fps25;       fps = 25.0;  break;
+                case Vst2::vstSmpteRateFps2997:      rate = AudioPlayHead::fps2997;     fps = 30.0 * 1000.0 / 1001.0; break;
+                case Vst2::vstSmpteRateFps30:        rate = AudioPlayHead::fps30;       fps = 30.0;  break;
+                case Vst2::vstSmpteRateFps2997drop:  rate = AudioPlayHead::fps2997drop; fps = 30.0 * 1000.0 / 1001.0; break;
+                case Vst2::vstSmpteRateFps30drop:    rate = AudioPlayHead::fps30drop;   fps = 30.0;  break;
+
+                case Vst2::vstSmpteRate16mmFilm:
+                case Vst2::vstSmpteRate35mmFilm:     fps = 24.0; break;
+
+                case Vst2::vstSmpteRateFps249:       fps = 25.0 * 1000.0 / 1001.0; break;
+                case Vst2::vstSmpteRateFps599:       fps = 60.0 * 1000.0 / 1001.0; break;
+                case Vst2::vstSmpteRateFps60:        fps = 60; break;
+
+                default:                       jassertfalse; // unknown frame-rate..
             }
 
             info.frameRate = rate;
@@ -716,14 +708,14 @@ public:
             info.editOriginTime = 0;
         }
 
-        info.isRecording = (ti->flags & Vst2::kVstTransportRecording) != 0;
-        info.isPlaying   = (ti->flags & (Vst2::kVstTransportRecording | Vst2::kVstTransportPlaying)) != 0;
-        info.isLooping   = (ti->flags & Vst2::kVstTransportCycleActive) != 0;
+        info.isRecording = (ti->flags & Vst2::vstTimingInfoFlagCurrentlyRecording) != 0;
+        info.isPlaying   = (ti->flags & (Vst2::vstTimingInfoFlagCurrentlyRecording | Vst2::vstTimingInfoFlagCurrentlyPlaying)) != 0;
+        info.isLooping   = (ti->flags & Vst2::vstTimingInfoFlagLoopActive) != 0;
 
-        if ((ti->flags & Vst2::kVstCyclePosValid) != 0)
+        if ((ti->flags & Vst2::vstTimingInfoFlagLoopPositionValid) != 0)
         {
-            info.ppqLoopStart = ti->cycleStartPos;
-            info.ppqLoopEnd   = ti->cycleEndPos;
+            info.ppqLoopStart = ti->loopStartPosition;
+            info.ppqLoopEnd   = ti->loopEndPosition;
         }
         else
         {
@@ -743,7 +735,7 @@ public:
         return 0.0f;
     }
 
-    static float getParameterCB (Vst2::AEffect* vstInterface, int32 index)
+    static float getParameterCB (Vst2::VstEffectInterface* vstInterface, int32 index)
     {
         return getWrapper (vstInterface)->getParameter (index);
     }
@@ -759,7 +751,7 @@ public:
         }
     }
 
-    static void setParameterCB (Vst2::AEffect* vstInterface, int32 index, float value)
+    static void setParameterCB (Vst2::VstEffectInterface* vstInterface, int32 index, float value)
     {
         getWrapper (vstInterface)->setParameter (index, value);
     }
@@ -773,19 +765,19 @@ public:
         }
 
         if (hostCallback != nullptr)
-            hostCallback (&vstEffect, Vst2::audioMasterAutomate, index, 0, nullptr, newValue);
+            hostCallback (&vstEffect, Vst2::hostOpcodeParameterChanged, index, 0, nullptr, newValue);
     }
 
     void audioProcessorParameterChangeGestureBegin (AudioProcessor*, int index) override
     {
         if (hostCallback != nullptr)
-            hostCallback (&vstEffect, Vst2::audioMasterBeginEdit, index, 0, nullptr, 0);
+            hostCallback (&vstEffect, Vst2::hostOpcodeParameterChangeGestureBegin, index, 0, nullptr, 0);
     }
 
     void audioProcessorParameterChangeGestureEnd (AudioProcessor*, int index) override
     {
         if (hostCallback != nullptr)
-            hostCallback (&vstEffect, Vst2::audioMasterEndEdit, index, 0, nullptr, 0);
+            hostCallback (&vstEffect, Vst2::hostOpcodeParameterChangeGestureEnd, index, 0, nullptr, 0);
     }
 
     void parameterValueChanged (int, float newValue) override
@@ -798,7 +790,7 @@ public:
 
     void audioProcessorChanged (AudioProcessor*) override
     {
-        vstEffect.initialDelay = processor->getLatencySamples();
+        vstEffect.latency = processor->getLatencySamples();
         triggerAsyncUpdate();
     }
 
@@ -806,12 +798,12 @@ public:
     {
         if (hostCallback != nullptr)
         {
-            hostCallback (&vstEffect, Vst2::audioMasterUpdateDisplay, 0, 0, nullptr, 0);
-            hostCallback (&vstEffect, Vst2::audioMasterIOChanged,     0, 0, nullptr, 0);
+            hostCallback (&vstEffect, Vst2::hostOpcodeUpdateView, 0, 0, nullptr, 0);
+            hostCallback (&vstEffect, Vst2::hostOpcodeIOModified,     0, 0, nullptr, 0);
         }
     }
 
-    bool getPinProperties (Vst2::VstPinProperties& properties, bool direction, int index) const
+    bool getPinProperties (Vst2::VstPinInfo& properties, bool direction, int index) const
     {
         if (processor->isMidiEffect())
             return false;
@@ -820,9 +812,9 @@ public:
 
         // fill with default
         properties.flags = 0;
-        properties.label[0] = 0;
-        properties.shortLabel[0] = 0;
-        properties.arrangementType = Vst2::kSpeakerArrEmpty;
+        properties.text[0] = 0;
+        properties.shortText[0] = 0;
+        properties.configurationType = Vst2::vstSpeakerConfigTypeEmpty;
 
         if ((channelIdx = processor->getOffsetInBusBufferForAbsoluteChannelIndex (direction, index, busIdx)) >= 0)
         {
@@ -830,8 +822,8 @@ public:
             auto& channelSet = bus.getCurrentLayout();
             auto channelType = channelSet.getTypeOfChannel (channelIdx);
 
-            properties.flags = Vst2::kVstPinIsActive | Vst2::kVstPinUseSpeaker;
-            properties.arrangementType = SpeakerMappings::channelSetToVstArrangementType (channelSet);
+            properties.flags = Vst2::vstPinInfoFlagIsActive | Vst2::vstPinInfoFlagValid;
+            properties.configurationType = SpeakerMappings::channelSetToVstArrangementType (channelSet);
             String label = bus.getName();
 
            #ifdef JucePlugin_PreferredChannelConfigurations
@@ -841,8 +833,8 @@ public:
                 label += " " + AudioChannelSet::getAbbreviatedChannelTypeName (channelType);
            #endif
 
-            label.copyToUTF8 (properties.label, (size_t) (Vst2::kVstMaxLabelLen + 1));
-            label.copyToUTF8 (properties.shortLabel, (size_t) (Vst2::kVstMaxShortLabelLen + 1));
+            label.copyToUTF8 (properties.text, (size_t) (Vst2::vstMaxParameterOrPinLabelLength + 1));
+            label.copyToUTF8 (properties.shortText, (size_t) (Vst2::vstMaxParameterOrPinShortLabelLength + 1));
 
             if (channelType == AudioChannelSet::left
                 || channelType == AudioChannelSet::leftSurround
@@ -852,7 +844,7 @@ public:
                 || channelType == AudioChannelSet::topRearLeft
                 || channelType == AudioChannelSet::leftSurroundRear
                 || channelType == AudioChannelSet::wideLeft)
-                properties.flags |= Vst2::kVstPinIsStereo;
+                properties.flags |= Vst2::vstPinInfoFlagIsStereo;
 
             return true;
         }
@@ -887,15 +879,15 @@ public:
 
     void setHasEditorFlag (bool shouldSetHasEditor)
     {
-        auto hasEditor = (vstEffect.flags & Vst2::effFlagsHasEditor) != 0;
+        auto hasEditor = (vstEffect.flags & Vst2::vstEffectFlagHasEditor) != 0;
 
         if (shouldSetHasEditor == hasEditor)
             return;
 
         if (shouldSetHasEditor)
-            vstEffect.flags |= Vst2::effFlagsHasEditor;
+            vstEffect.flags |= Vst2::vstEffectFlagHasEditor;
         else
-            vstEffect.flags &= ~Vst2::effFlagsHasEditor;
+            vstEffect.flags &= ~Vst2::vstEffectFlagHasEditor;
     }
 
     void createEditorComp()
@@ -962,59 +954,59 @@ public:
 
         switch (opCode)
         {
-            case Vst2::effOpen:                     return handleOpen (args);
-            case Vst2::effClose:                    return handleClose (args);
-            case Vst2::effSetProgram:               return handleSetCurrentProgram (args);
-            case Vst2::effGetProgram:               return handleGetCurrentProgram (args);
-            case Vst2::effSetProgramName:           return handleSetCurrentProgramName (args);
-            case Vst2::effGetProgramName:           return handleGetCurrentProgramName (args);
-            case Vst2::effGetParamLabel:            return handleGetParameterLabel (args);
-            case Vst2::effGetParamDisplay:          return handleGetParameterText (args);
-            case Vst2::effGetParamName:             return handleGetParameterName (args);
-            case Vst2::effSetSampleRate:            return handleSetSampleRate (args);
-            case Vst2::effSetBlockSize:             return handleSetBlockSize (args);
-            case Vst2::effMainsChanged:             return handleResumeSuspend (args);
-            case Vst2::effEditGetRect:              return handleGetEditorBounds (args);
-            case Vst2::effEditOpen:                 return handleOpenEditor (args);
-            case Vst2::effEditClose:                return handleCloseEditor (args);
-            case Vst2::effIdentify:                 return (pointer_sized_int) ByteOrder::bigEndianInt ("NvEf");
-            case Vst2::effGetChunk:                 return handleGetData (args);
-            case Vst2::effSetChunk:                 return handleSetData (args);
-            case Vst2::effProcessEvents:            return handlePreAudioProcessingEvents (args);
-            case Vst2::effCanBeAutomated:           return handleIsParameterAutomatable (args);
-            case Vst2::effString2Parameter:         return handleParameterValueForText (args);
-            case Vst2::effGetProgramNameIndexed:    return handleGetProgramName (args);
-            case Vst2::effGetInputProperties:       return handleGetInputPinProperties (args);
-            case Vst2::effGetOutputProperties:      return handleGetOutputPinProperties (args);
-            case Vst2::effGetPlugCategory:          return handleGetPlugInCategory (args);
-            case Vst2::effSetSpeakerArrangement:    return handleSetSpeakerConfiguration (args);
-            case Vst2::effSetBypass:                return handleSetBypass (args);
-            case Vst2::effGetEffectName:            return handleGetPlugInName (args);
-            case Vst2::effGetProductString:         return handleGetPlugInName (args);
-            case Vst2::effGetVendorString:          return handleGetManufacturerName (args);
-            case Vst2::effGetVendorVersion:         return handleGetManufacturerVersion (args);
-            case Vst2::effVendorSpecific:           return handleManufacturerSpecific (args);
-            case Vst2::effCanDo:                    return handleCanPlugInDo (args);
-            case Vst2::effGetTailSize:              return handleGetTailSize (args);
-            case Vst2::effKeysRequired:             return handleKeyboardFocusRequired (args);
-            case Vst2::effGetVstVersion:            return handleGetVstInterfaceVersion (args);
-            case Vst2::effGetCurrentMidiProgram:    return handleGetCurrentMidiProgram (args);
-            case Vst2::effGetSpeakerArrangement:    return handleGetSpeakerConfiguration (args);
-            case Vst2::effSetTotalSampleToProcess:  return handleSetNumberOfSamplesToProcess (args);
-            case Vst2::effSetProcessPrecision:      return handleSetSampleFloatType (args);
-            case Vst2::effGetNumMidiInputChannels:  return handleGetNumMidiInputChannels();
-            case Vst2::effGetNumMidiOutputChannels: return handleGetNumMidiOutputChannels();
-            default:                                return 0;
-        }
-    }
-
-    static pointer_sized_int dispatcherCB (Vst2::AEffect* vstInterface, int32 opCode, int32 index,
+            case Vst2::plugInOpcodeOpen:                        return handleOpen (args);
+            case Vst2::plugInOpcodeClose:                       return handleClose (args);
+            case Vst2::plugInOpcodeSetCurrentProgram:           return handleSetCurrentProgram (args);
+            case Vst2::plugInOpcodeGetCurrentProgram:           return handleGetCurrentProgram (args);
+            case Vst2::plugInOpcodeSetCurrentProgramName:       return handleSetCurrentProgramName (args);
+            case Vst2::plugInOpcodeGetCurrentProgramName:       return handleGetCurrentProgramName (args);
+            case Vst2::plugInOpcodeGetParameterLabel:           return handleGetParameterLabel (args);
+            case Vst2::plugInOpcodeGetParameterText:            return handleGetParameterText (args);
+            case Vst2::plugInOpcodeGetParameterName:            return handleGetParameterName (args);
+            case Vst2::plugInOpcodeSetSampleRate:               return handleSetSampleRate (args);
+            case Vst2::plugInOpcodeSetBlockSize:                return handleSetBlockSize (args);
+            case Vst2::plugInOpcodeResumeSuspend:               return handleResumeSuspend (args);
+            case Vst2::plugInOpcodeGetEditorBounds:             return handleGetEditorBounds (args);
+            case Vst2::plugInOpcodeOpenEditor:                  return handleOpenEditor (args);
+            case Vst2::plugInOpcodeCloseEditor:                 return handleCloseEditor (args);
+            case Vst2::plugInOpcodeIdentify:                    return (pointer_sized_int) ByteOrder::bigEndianInt ("NvEf");
+            case Vst2::plugInOpcodeGetData:                     return handleGetData (args);
+            case Vst2::plugInOpcodeSetData:                     return handleSetData (args);
+            case Vst2::plugInOpcodePreAudioProcessingEvents:    return handlePreAudioProcessingEvents (args);
+            case Vst2::plugInOpcodeIsParameterAutomatable:      return handleIsParameterAutomatable (args);
+            case Vst2::plugInOpcodeParameterValueForText:       return handleParameterValueForText (args);
+            case Vst2::plugInOpcodeGetProgramName:              return handleGetProgramName (args);
+            case Vst2::plugInOpcodeGetInputPinProperties:       return handleGetInputPinProperties (args);
+            case Vst2::plugInOpcodeGetOutputPinProperties:      return handleGetOutputPinProperties (args);
+            case Vst2::plugInOpcodeGetPlugInCategory:           return handleGetPlugInCategory (args);
+            case Vst2::plugInOpcodeSetSpeakerConfiguration:     return handleSetSpeakerConfiguration (args);
+            case Vst2::plugInOpcodeSetBypass:                   return handleSetBypass (args);
+            case Vst2::plugInOpcodeGetPlugInName:               return handleGetPlugInName (args);
+            case Vst2::plugInOpcodeGetManufacturerProductName:  return handleGetPlugInName (args);
+            case Vst2::plugInOpcodeGetManufacturerName:         return handleGetManufacturerName (args);
+            case Vst2::plugInOpcodeGetManufacturerVersion:      return handleGetManufacturerVersion (args);
+            case Vst2::plugInOpcodeManufacturerSpecific:        return handleManufacturerSpecific (args);
+            case Vst2::plugInOpcodeCanPlugInDo:                 return handleCanPlugInDo (args);
+            case Vst2::plugInOpcodeGetTailSize:                 return handleGetTailSize (args);
+            case Vst2::plugInOpcodeKeyboardFocusRequired:       return handleKeyboardFocusRequired (args);
+            case Vst2::plugInOpcodeGetVstInterfaceVersion:      return handleGetVstInterfaceVersion (args);
+            case Vst2::plugInOpcodeGetCurrentMidiProgram:       return handleGetCurrentMidiProgram (args);
+            case Vst2::plugInOpcodeGetSpeakerArrangement:       return handleGetSpeakerConfiguration (args);
+            case Vst2::plugInOpcodeSetNumberOfSamplesToProcess: return handleSetNumberOfSamplesToProcess (args);
+            case Vst2::plugInOpcodeSetSampleFloatType:          return handleSetSampleFloatType (args);
+            case Vst2::pluginOpcodeGetNumMidiInputChannels:     return handleGetNumMidiInputChannels();
+            case Vst2::pluginOpcodeGetNumMidiOutputChannels:    return handleGetNumMidiOutputChannels();
+            default:                                            return 0;
+        }
+    }
+
+    static pointer_sized_int dispatcherCB (Vst2::VstEffectInterface* vstInterface, int32 opCode, int32 index,
                                            pointer_sized_int value, void* ptr, float opt)
     {
         auto* wrapper = getWrapper (vstInterface);
         VstOpCodeArguments args = { index, value, ptr, opt };
 
-        if (opCode == Vst2::effClose)
+        if (opCode == Vst2::plugInOpcodeClose)
         {
             wrapper->dispatcher (opCode, args);
             delete wrapper;
@@ -1214,13 +1206,13 @@ public:
 
             if (auto host = wrapper.hostCallback)
             {
-                auto status = host (wrapper.getAEffect(), Vst2::audioMasterCanDo, 0, 0, const_cast<char*> ("sizeWindow"), 0);
+                auto status = host (wrapper.getAEffect(), Vst2::hostOpcodeCanHostDo, 0, 0, const_cast<char*> ("sizeWindow"), 0);
 
                 if (status == (pointer_sized_int) 1 || getHostType().isAbletonLive())
                 {
                     const ScopedValueSetter<bool> inSizeWindowSetter (isInSizeWindow, true);
 
-                    sizeWasSuccessful = (host (wrapper.getAEffect(), Vst2::audioMasterSizeWindow,
+                    sizeWasSuccessful = (host (wrapper.getAEffect(), Vst2::hostOpcodeWindowSize,
                                                newWidth, newHeight, nullptr, 0) != 0);
                 }
             }
@@ -1376,12 +1368,12 @@ public:
 
     //==============================================================================
 private:
-    static JuceVSTWrapper* getWrapper (Vst2::AEffect* v) noexcept  { return static_cast<JuceVSTWrapper*> (v->object); }
+    static JuceVSTWrapper* getWrapper (Vst2::VstEffectInterface* v) noexcept  { return static_cast<JuceVSTWrapper*> (v->effectPointer); }
 
     bool isProcessLevelOffline()
     {
         return hostCallback != nullptr
-                && (int32) hostCallback (&vstEffect, Vst2::audioMasterGetCurrentProcessLevel, 0, 0, nullptr, 0) == 4;
+                && (int32) hostCallback (&vstEffect, Vst2::hostOpcodeGetCurrentAudioProcessingLevel, 0, 0, nullptr, 0) == 4;
     }
 
     static inline int32 convertHexVersionToDecimal (const unsigned int hexVersion)
@@ -1449,8 +1441,8 @@ private:
         tmpBuffers.release();
 
         if (processor != nullptr)
-            tmpBuffers.tempChannels.insertMultiple (0, nullptr, vstEffect.numInputs
-                                                                 + vstEffect.numOutputs);
+            tmpBuffers.tempChannels.insertMultiple (0, nullptr, vstEffect.numInputChannels
+                                                                 + vstEffect.numOutputChannels);
     }
 
     void deleteTempChannels()
@@ -1610,7 +1602,7 @@ private:
         if (editorComp != nullptr)
         {
             editorComp->getEditorBounds (editorBounds);
-            *((Vst2::ERect**) args.ptr) = &editorBounds;
+            *((Vst2::VstEditorBounds**) args.ptr) = &editorBounds;
             return (pointer_sized_int) &editorBounds;
         }
 
@@ -1700,7 +1692,7 @@ private:
     pointer_sized_int handlePreAudioProcessingEvents (VstOpCodeArguments args)
     {
        #if JucePlugin_WantsMidiInput || JucePlugin_IsMidiEffect
-        VSTMidiEventList::addEventsToMidiBuffer ((Vst2::VstEvents*) args.ptr, midiEvents);
+        VSTMidiEventList::addEventsToMidiBuffer ((Vst2::VstEventBlock*) args.ptr, midiEvents);
         return 1;
        #else
         ignoreUnused (args);
@@ -1751,12 +1743,12 @@ private:
 
     pointer_sized_int handleGetInputPinProperties (VstOpCodeArguments args)
     {
-        return (processor != nullptr && getPinProperties (*(Vst2::VstPinProperties*) args.ptr, true, args.index)) ? 1 : 0;
+        return (processor != nullptr && getPinProperties (*(Vst2::VstPinInfo*) args.ptr, true, args.index)) ? 1 : 0;
     }
 
     pointer_sized_int handleGetOutputPinProperties (VstOpCodeArguments args)
     {
-        return (processor != nullptr && getPinProperties (*(Vst2::VstPinProperties*) args.ptr, false, args.index)) ? 1 : 0;
+        return (processor != nullptr && getPinProperties (*(Vst2::VstPinInfo*) args.ptr, false, args.index)) ? 1 : 0;
     }
 
     pointer_sized_int handleGetPlugInCategory (VstOpCodeArguments)
@@ -1766,8 +1758,8 @@ private:
 
     pointer_sized_int handleSetSpeakerConfiguration (VstOpCodeArguments args)
     {
-        auto* pluginInput  = reinterpret_cast<Vst2::VstSpeakerArrangement*> (args.value);
-        auto* pluginOutput = reinterpret_cast<Vst2::VstSpeakerArrangement*> (args.ptr);
+        auto* pluginInput  = reinterpret_cast<Vst2::VstSpeakerConfiguration*> (args.value);
+        auto* pluginOutput = reinterpret_cast<Vst2::VstSpeakerConfiguration*> (args.ptr);
 
         if (processor->isMidiEffect())
             return 0;
@@ -1778,29 +1770,29 @@ private:
         if (pluginInput != nullptr && pluginInput->type >= 0)
         {
             // inconsistent request?
-            if (SpeakerMappings::vstArrangementTypeToChannelSet (*pluginInput).size() != pluginInput->numChannels)
+            if (SpeakerMappings::vstArrangementTypeToChannelSet (*pluginInput).size() != pluginInput->numberOfChannels)
                 return 0;
         }
 
         if (pluginOutput != nullptr && pluginOutput->type >= 0)
         {
             // inconsistent request?
-            if (SpeakerMappings::vstArrangementTypeToChannelSet (*pluginOutput).size() != pluginOutput->numChannels)
+            if (SpeakerMappings::vstArrangementTypeToChannelSet (*pluginOutput).size() != pluginOutput->numberOfChannels)
                 return 0;
         }
 
-        if (pluginInput != nullptr  && pluginInput->numChannels  > 0 && numIns  == 0)
+        if (pluginInput != nullptr  && pluginInput->numberOfChannels  > 0 && numIns  == 0)
             return 0;
 
-        if (pluginOutput != nullptr && pluginOutput->numChannels > 0 && numOuts == 0)
+        if (pluginOutput != nullptr && pluginOutput->numberOfChannels > 0 && numOuts == 0)
             return 0;
 
         auto layouts = processor->getBusesLayout();
 
-        if (pluginInput != nullptr && pluginInput-> numChannels >= 0 && numIns  > 0)
+        if (pluginInput != nullptr && pluginInput-> numberOfChannels >= 0 && numIns  > 0)
             layouts.getChannelSet (true,  0) = SpeakerMappings::vstArrangementTypeToChannelSet (*pluginInput);
 
-        if (pluginOutput != nullptr && pluginOutput->numChannels >= 0 && numOuts > 0)
+        if (pluginOutput != nullptr && pluginOutput->numberOfChannels >= 0 && numOuts > 0)
             layouts.getChannelSet (false, 0) = SpeakerMappings::vstArrangementTypeToChannelSet (*pluginOutput);
 
        #ifdef JucePlugin_PreferredChannelConfigurations
@@ -1848,7 +1840,7 @@ private:
              && args.value == (int32) JUCE_MULTICHAR_CONSTANT ('A', 'e', 'C', 's'))
             return handleSetContentScaleFactor (args.opt);
 
-        if (args.index == Vst2::effGetParamDisplay)
+        if (args.index == Vst2::plugInOpcodeGetParameterText)
             return handleCockosGetParameterText (args.value, args.ptr, args.opt);
 
         if (auto callbackHandler = dynamic_cast<VSTCallbackHandler*> (processor))
@@ -1943,7 +1935,7 @@ private:
 
     pointer_sized_int handleGetVstInterfaceVersion (VstOpCodeArguments)
     {
-        return kVstVersion;
+        return Vst2::juceVstInterfaceVersion;
     }
 
     pointer_sized_int handleGetCurrentMidiProgram (VstOpCodeArguments)
@@ -1953,8 +1945,8 @@ private:
 
     pointer_sized_int handleGetSpeakerConfiguration (VstOpCodeArguments args)
     {
-        auto** pluginInput  = reinterpret_cast<Vst2::VstSpeakerArrangement**> (args.value);
-        auto** pluginOutput = reinterpret_cast<Vst2::VstSpeakerArrangement**> (args.ptr);
+        auto** pluginInput  = reinterpret_cast<Vst2::VstSpeakerConfiguration**> (args.value);
+        auto** pluginOutput = reinterpret_cast<Vst2::VstSpeakerConfiguration**> (args.ptr);
 
         if (pluginHasSidechainsOrAuxs() || processor->isMidiEffect())
             return false;
@@ -1962,10 +1954,10 @@ private:
         auto inputLayout  = processor->getChannelLayoutOfBus (true,  0);
         auto outputLayout = processor->getChannelLayoutOfBus (false,  0);
 
-        auto speakerBaseSize = sizeof (Vst2::VstSpeakerArrangement) - (sizeof (Vst2::VstSpeakerProperties) * 8);
+        auto speakerBaseSize = sizeof (Vst2::VstSpeakerConfiguration) - (sizeof (Vst2::VstIndividualSpeakerInfo) * 8);
 
-        cachedInArrangement .malloc (speakerBaseSize + (static_cast<std::size_t> (inputLayout. size()) * sizeof (Vst2::VstSpeakerArrangement)), 1);
-        cachedOutArrangement.malloc (speakerBaseSize + (static_cast<std::size_t> (outputLayout.size()) * sizeof (Vst2::VstSpeakerArrangement)), 1);
+        cachedInArrangement .malloc (speakerBaseSize + (static_cast<std::size_t> (inputLayout. size()) * sizeof (Vst2::VstSpeakerConfiguration)), 1);
+        cachedOutArrangement.malloc (speakerBaseSize + (static_cast<std::size_t> (outputLayout.size()) * sizeof (Vst2::VstSpeakerConfiguration)), 1);
 
         *pluginInput  = cachedInArrangement. getData();
         *pluginOutput = cachedOutArrangement.getData();
@@ -1987,7 +1979,7 @@ private:
         {
             if (processor != nullptr)
             {
-                processor->setProcessingPrecision ((args.value == Vst2::kVstProcessPrecision64
+                processor->setProcessingPrecision ((args.value == Vst2::vstProcessingSampleTypeDouble
                                                      && processor->supportsDoublePrecisionProcessing())
                                                          ? AudioProcessor::doublePrecision
                                                          : AudioProcessor::singlePrecision);
@@ -2061,16 +2053,16 @@ private:
     }
 
     //==============================================================================
-    Vst2::audioMasterCallback hostCallback;
+    Vst2::VstHostCallback hostCallback;
     AudioProcessor* processor = {};
     double sampleRate = 44100.0;
     int32 blockSize = 1024;
-    Vst2::AEffect vstEffect;
+    Vst2::VstEffectInterface vstEffect;
     CriticalSection stateInformationLock;
     juce::MemoryBlock chunkMemory;
     uint32 chunkMemoryTime = 0;
     std::unique_ptr<EditorCompWrapper> editorComp;
-    Vst2::ERect editorBounds;
+    Vst2::VstEditorBounds editorBounds;
     MidiBuffer midiEvents;
     VSTMidiEventList outgoingEvents;
 
@@ -2095,7 +2087,7 @@ private:
     VstTempBuffers<double> doubleTempBuffers;
     int maxNumInChannels = 0, maxNumOutChannels = 0;
 
-    HeapBlock<Vst2::VstSpeakerArrangement> cachedInArrangement, cachedOutArrangement;
+    HeapBlock<Vst2::VstSpeakerConfiguration> cachedInArrangement, cachedOutArrangement;
 
     ThreadLocalValue<bool> inParameterChangedCallback;
 
@@ -2107,7 +2099,7 @@ private:
 //==============================================================================
 namespace
 {
-    Vst2::AEffect* pluginEntryPoint (Vst2::audioMasterCallback audioMaster)
+    Vst2::VstEffectInterface* pluginEntryPoint (Vst2::VstHostCallback audioMaster)
     {
         JUCE_AUTORELEASEPOOL
         {
@@ -2115,7 +2107,7 @@ namespace
 
             try
             {
-                if (audioMaster (nullptr, Vst2::audioMasterVersion, 0, 0, nullptr, 0) != 0)
+                if (audioMaster (nullptr, Vst2::hostOpcodeVstVersion, 0, 0, nullptr, 0) != 0)
                 {
                    #if JUCE_LINUX
                     MessageManagerLock mmLock;
@@ -2152,8 +2144,8 @@ namespace
 // Mac startup code..
 #if JUCE_MAC
 
-    JUCE_EXPORTED_FUNCTION Vst2::AEffect* VSTPluginMain (Vst2::audioMasterCallback audioMaster);
-    JUCE_EXPORTED_FUNCTION Vst2::AEffect* VSTPluginMain (Vst2::audioMasterCallback audioMaster)
+    JUCE_EXPORTED_FUNCTION Vst2::VstEffectInterface* VSTPluginMain (Vst2::VstHostCallback audioMaster);
+    JUCE_EXPORTED_FUNCTION Vst2::VstEffectInterface* VSTPluginMain (Vst2::VstHostCallback audioMaster)
     {
         PluginHostType::jucePlugInClientCurrentWrapperType = AudioProcessor::wrapperType_VST;
 
@@ -2161,8 +2153,8 @@ namespace
         return pluginEntryPoint (audioMaster);
     }
 
-    JUCE_EXPORTED_FUNCTION Vst2::AEffect* main_macho (Vst2::audioMasterCallback audioMaster);
-    JUCE_EXPORTED_FUNCTION Vst2::AEffect* main_macho (Vst2::audioMasterCallback audioMaster)
+    JUCE_EXPORTED_FUNCTION Vst2::VstEffectInterface* main_macho (Vst2::VstHostCallback audioMaster);
+    JUCE_EXPORTED_FUNCTION Vst2::VstEffectInterface* main_macho (Vst2::VstHostCallback audioMaster)
     {
         PluginHostType::jucePlugInClientCurrentWrapperType = AudioProcessor::wrapperType_VST;
 
@@ -2174,8 +2166,8 @@ namespace
 // Linux startup code..
 #elif JUCE_LINUX
 
-    JUCE_EXPORTED_FUNCTION Vst2::AEffect* VSTPluginMain (Vst2::audioMasterCallback audioMaster);
-    JUCE_EXPORTED_FUNCTION Vst2::AEffect* VSTPluginMain (Vst2::audioMasterCallback audioMaster)
+    JUCE_EXPORTED_FUNCTION Vst2::VstEffectInterface* VSTPluginMain (Vst2::VstHostCallback audioMaster);
+    JUCE_EXPORTED_FUNCTION Vst2::VstEffectInterface* VSTPluginMain (Vst2::VstHostCallback audioMaster)
     {
         PluginHostType::jucePlugInClientCurrentWrapperType = AudioProcessor::wrapperType_VST;
 
@@ -2183,8 +2175,8 @@ namespace
         return pluginEntryPoint (audioMaster);
     }
 
-    JUCE_EXPORTED_FUNCTION Vst2::AEffect* main_plugin (Vst2::audioMasterCallback audioMaster) asm ("main");
-    JUCE_EXPORTED_FUNCTION Vst2::AEffect* main_plugin (Vst2::audioMasterCallback audioMaster)
+    JUCE_EXPORTED_FUNCTION Vst2::VstEffectInterface* main_plugin (Vst2::VstHostCallback audioMaster) asm ("main");
+    JUCE_EXPORTED_FUNCTION Vst2::VstEffectInterface* main_plugin (Vst2::VstHostCallback audioMaster)
     {
         PluginHostType::jucePlugInClientCurrentWrapperType = AudioProcessor::wrapperType_VST;
 
@@ -2199,7 +2191,7 @@ namespace
 // Win32 startup code..
 #else
 
-    extern "C" __declspec (dllexport) Vst2::AEffect* VSTPluginMain (Vst2::audioMasterCallback audioMaster)
+    extern "C" __declspec (dllexport) Vst2::VstEffectInterface* VSTPluginMain (Vst2::VstHostCallback audioMaster)
     {
         PluginHostType::jucePlugInClientCurrentWrapperType = AudioProcessor::wrapperType_VST;
 
@@ -2207,7 +2199,7 @@ namespace
     }
 
    #ifndef JUCE_64BIT // (can't compile this on win64, but it's not needed anyway with VST2.4)
-    extern "C" __declspec (dllexport) int main (Vst2::audioMasterCallback audioMaster)
+    extern "C" __declspec (dllexport) int main (Vst2::VstHostCallback audioMaster)
     {
         PluginHostType::jucePlugInClientCurrentWrapperType = AudioProcessor::wrapperType_VST;
 
diff --git a/modules/juce_audio_processors/format_types/juce_VSTCommon.h b/modules/juce_audio_processors/format_types/juce_VSTCommon.h
index 25436f9bf..0862f830f 100644
--- a/modules/juce_audio_processors/format_types/juce_VSTCommon.h
+++ b/modules/juce_audio_processors/format_types/juce_VSTCommon.h
@@ -58,25 +58,25 @@ struct SpeakerMappings  : private AudioChannelSet // (inheritance only to give e
 
     static AudioChannelSet vstArrangementTypeToChannelSet (int32 arr, int fallbackNumChannels)
     {
-        if      (arr == Vst2::kSpeakerArrEmpty)        return AudioChannelSet::disabled();
-        else if (arr == Vst2::kSpeakerArrMono)         return AudioChannelSet::mono();
-        else if (arr == Vst2::kSpeakerArrStereo)       return AudioChannelSet::stereo();
-        else if (arr == Vst2::kSpeakerArr30Cine)       return AudioChannelSet::createLCR();
-        else if (arr == Vst2::kSpeakerArr30Music)      return AudioChannelSet::createLRS();
-        else if (arr == Vst2::kSpeakerArr40Cine)       return AudioChannelSet::createLCRS();
-        else if (arr == Vst2::kSpeakerArr50)           return AudioChannelSet::create5point0();
-        else if (arr == Vst2::kSpeakerArr51)           return AudioChannelSet::create5point1();
-        else if (arr == Vst2::kSpeakerArr60Cine)       return AudioChannelSet::create6point0();
-        else if (arr == Vst2::kSpeakerArr61Cine)       return AudioChannelSet::create6point1();
-        else if (arr == Vst2::kSpeakerArr60Music)      return AudioChannelSet::create6point0Music();
-        else if (arr == Vst2::kSpeakerArr61Music)      return AudioChannelSet::create6point1Music();
-        else if (arr == Vst2::kSpeakerArr70Music)      return AudioChannelSet::create7point0();
-        else if (arr == Vst2::kSpeakerArr70Cine)       return AudioChannelSet::create7point0SDDS();
-        else if (arr == Vst2::kSpeakerArr71Music)      return AudioChannelSet::create7point1();
-        else if (arr == Vst2::kSpeakerArr71Cine)       return AudioChannelSet::create7point1SDDS();
-        else if (arr == Vst2::kSpeakerArr40Music)      return AudioChannelSet::quadraphonic();
-
-        for (const Mapping* m = getMappings(); m->vst2 != Vst2::kSpeakerArrEmpty; ++m)
+        if      (arr == Vst2::vstSpeakerConfigTypeEmpty)          return AudioChannelSet::disabled();
+        else if (arr == Vst2::vstSpeakerConfigTypeMono)           return AudioChannelSet::mono();
+        else if (arr == Vst2::vstSpeakerConfigTypeLR)             return AudioChannelSet::stereo();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRC)            return AudioChannelSet::createLCR();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRS)            return AudioChannelSet::createLRS();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRCS)           return AudioChannelSet::createLCRS();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRCLsRs)        return AudioChannelSet::create5point0();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRCLfeLsRs)     return AudioChannelSet::create5point1();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRCLsRsCs)      return AudioChannelSet::create6point0();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRCLfeLsRsCs)   return AudioChannelSet::create6point1();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRLsRsSlSr)     return AudioChannelSet::create6point0Music();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRLfeLsRsSlSr)  return AudioChannelSet::create6point1Music();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRCLsRsSlSr)    return AudioChannelSet::create7point0();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRCLsRsLcRc)    return AudioChannelSet::create7point0SDDS();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRCLfeLsRsSlSr) return AudioChannelSet::create7point1();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRCLfeLsRsLcRc) return AudioChannelSet::create7point1SDDS();
+        else if (arr == Vst2::vstSpeakerConfigTypeLRLsRs)         return AudioChannelSet::quadraphonic();
+
+        for (const Mapping* m = getMappings(); m->vst2 != Vst2::vstSpeakerConfigTypeEmpty; ++m)
         {
             if (m->vst2 == arr)
             {
@@ -92,53 +92,53 @@ struct SpeakerMappings  : private AudioChannelSet // (inheritance only to give e
         return AudioChannelSet::discreteChannels (fallbackNumChannels);
     }
 
-    static AudioChannelSet vstArrangementTypeToChannelSet (const Vst2::VstSpeakerArrangement& arr)
+    static AudioChannelSet vstArrangementTypeToChannelSet (const Vst2::VstSpeakerConfiguration& arr)
     {
-        return vstArrangementTypeToChannelSet (arr.type, arr.numChannels);
+        return vstArrangementTypeToChannelSet (arr.type, arr.numberOfChannels);
     }
 
     static int32 channelSetToVstArrangementType (AudioChannelSet channels)
     {
-        if      (channels == AudioChannelSet::disabled())           return Vst2::kSpeakerArrEmpty;
-        else if (channels == AudioChannelSet::mono())               return Vst2::kSpeakerArrMono;
-        else if (channels == AudioChannelSet::stereo())             return Vst2::kSpeakerArrStereo;
-        else if (channels == AudioChannelSet::createLCR())          return Vst2::kSpeakerArr30Cine;
-        else if (channels == AudioChannelSet::createLRS())          return Vst2::kSpeakerArr30Music;
-        else if (channels == AudioChannelSet::createLCRS())         return Vst2::kSpeakerArr40Cine;
-        else if (channels == AudioChannelSet::create5point0())      return Vst2::kSpeakerArr50;
-        else if (channels == AudioChannelSet::create5point1())      return Vst2::kSpeakerArr51;
-        else if (channels == AudioChannelSet::create6point0())      return Vst2::kSpeakerArr60Cine;
-        else if (channels == AudioChannelSet::create6point1())      return Vst2::kSpeakerArr61Cine;
-        else if (channels == AudioChannelSet::create6point0Music()) return Vst2::kSpeakerArr60Music;
-        else if (channels == AudioChannelSet::create6point1Music()) return Vst2::kSpeakerArr61Music;
-        else if (channels == AudioChannelSet::create7point0())      return Vst2::kSpeakerArr70Music;
-        else if (channels == AudioChannelSet::create7point0SDDS())  return Vst2::kSpeakerArr70Cine;
-        else if (channels == AudioChannelSet::create7point1())      return Vst2::kSpeakerArr71Music;
-        else if (channels == AudioChannelSet::create7point1SDDS())  return Vst2::kSpeakerArr71Cine;
-        else if (channels == AudioChannelSet::quadraphonic())       return Vst2::kSpeakerArr40Music;
+        if      (channels == AudioChannelSet::disabled())           return Vst2::vstSpeakerConfigTypeEmpty;
+        else if (channels == AudioChannelSet::mono())               return Vst2::vstSpeakerConfigTypeMono;
+        else if (channels == AudioChannelSet::stereo())             return Vst2::vstSpeakerConfigTypeLR;
+        else if (channels == AudioChannelSet::createLCR())          return Vst2::vstSpeakerConfigTypeLRC;
+        else if (channels == AudioChannelSet::createLRS())          return Vst2::vstSpeakerConfigTypeLRS;
+        else if (channels == AudioChannelSet::createLCRS())         return Vst2::vstSpeakerConfigTypeLRCS;
+        else if (channels == AudioChannelSet::create5point0())      return Vst2::vstSpeakerConfigTypeLRCLsRs;
+        else if (channels == AudioChannelSet::create5point1())      return Vst2::vstSpeakerConfigTypeLRCLfeLsRs;
+        else if (channels == AudioChannelSet::create6point0())      return Vst2::vstSpeakerConfigTypeLRCLsRsCs;
+        else if (channels == AudioChannelSet::create6point1())      return Vst2::vstSpeakerConfigTypeLRCLfeLsRsCs;
+        else if (channels == AudioChannelSet::create6point0Music()) return Vst2::vstSpeakerConfigTypeLRLsRsSlSr;
+        else if (channels == AudioChannelSet::create6point1Music()) return Vst2::vstSpeakerConfigTypeLRLfeLsRsSlSr;
+        else if (channels == AudioChannelSet::create7point0())      return Vst2::vstSpeakerConfigTypeLRCLsRsSlSr;
+        else if (channels == AudioChannelSet::create7point0SDDS())  return Vst2::vstSpeakerConfigTypeLRCLsRsLcRc;
+        else if (channels == AudioChannelSet::create7point1())      return Vst2::vstSpeakerConfigTypeLRCLfeLsRsSlSr;
+        else if (channels == AudioChannelSet::create7point1SDDS())  return Vst2::vstSpeakerConfigTypeLRCLfeLsRsLcRc;
+        else if (channels == AudioChannelSet::quadraphonic())       return Vst2::vstSpeakerConfigTypeLRLsRs;
 
         if (channels == AudioChannelSet::disabled())
-            return Vst2::kSpeakerArrEmpty;
+            return Vst2::vstSpeakerConfigTypeEmpty;
 
         auto chans = channels.getChannelTypes();
 
-        for (auto* m = getMappings(); m->vst2 != Vst2::kSpeakerArrEmpty; ++m)
+        for (auto* m = getMappings(); m->vst2 != Vst2::vstSpeakerConfigTypeEmpty; ++m)
             if (m->matches (chans))
                 return m->vst2;
 
-        return Vst2::kSpeakerArrUserDefined;
+        return Vst2::vstSpeakerConfigTypeUser;
     }
 
-    static void channelSetToVstArrangement (const AudioChannelSet& channels, Vst2::VstSpeakerArrangement& result)
+    static void channelSetToVstArrangement (const AudioChannelSet& channels, Vst2::VstSpeakerConfiguration& result)
     {
         result.type = channelSetToVstArrangementType (channels);
-        result.numChannels = channels.size();
+        result.numberOfChannels = channels.size();
 
-        for (int i = 0; i < result.numChannels; ++i)
+        for (int i = 0; i < result.numberOfChannels; ++i)
         {
             auto& speaker = result.speakers[i];
 
-            zeromem (&speaker, sizeof (Vst2::VstSpeakerProperties));
+            zeromem (&speaker, sizeof (Vst2::VstIndividualSpeakerInfo));
             speaker.type = getSpeakerType (channels.getTypeOfChannel (i));
         }
     }
@@ -152,7 +152,7 @@ struct SpeakerMappings  : private AudioChannelSet // (inheritance only to give e
             clear();
         }
 
-        VstSpeakerConfigurationHolder (const Vst2::VstSpeakerArrangement& vstConfig)
+        VstSpeakerConfigurationHolder (const Vst2::VstSpeakerConfiguration& vstConfig)
         {
             operator= (vstConfig);
         }
@@ -171,29 +171,29 @@ struct SpeakerMappings  : private AudioChannelSet // (inheritance only to give e
         VstSpeakerConfigurationHolder (const AudioChannelSet& channels)
         {
             auto numberOfChannels = channels.size();
-            Vst2::VstSpeakerArrangement& dst = *allocate (numberOfChannels);
+            Vst2::VstSpeakerConfiguration& dst = *allocate (numberOfChannels);
 
             dst.type = channelSetToVstArrangementType (channels);
-            dst.numChannels = numberOfChannels;
+            dst.numberOfChannels = numberOfChannels;
 
-            for (int i = 0; i < dst.numChannels; ++i)
+            for (int i = 0; i < dst.numberOfChannels; ++i)
             {
-                Vst2::VstSpeakerProperties& speaker = dst.speakers[i];
+                Vst2::VstIndividualSpeakerInfo& speaker = dst.speakers[i];
 
-                zeromem (&speaker, sizeof (Vst2::VstSpeakerProperties));
+                zeromem (&speaker, sizeof (Vst2::VstIndividualSpeakerInfo));
                 speaker.type = getSpeakerType (channels.getTypeOfChannel (i));
             }
         }
 
         VstSpeakerConfigurationHolder& operator= (const VstSpeakerConfigurationHolder& vstConfig) { return operator=(vstConfig.get()); }
-        VstSpeakerConfigurationHolder& operator= (const Vst2::VstSpeakerArrangement& vstConfig)
+        VstSpeakerConfigurationHolder& operator= (const Vst2::VstSpeakerConfiguration& vstConfig)
         {
-            Vst2::VstSpeakerArrangement& dst = *allocate (vstConfig.numChannels);
+            Vst2::VstSpeakerConfiguration& dst = *allocate (vstConfig.numberOfChannels);
 
             dst.type             = vstConfig.type;
-            dst.numChannels      = vstConfig.numChannels;
+            dst.numberOfChannels = vstConfig.numberOfChannels;
 
-            for (int i = 0; i < dst.numChannels; ++i)
+            for (int i = 0; i < dst.numberOfChannels; ++i)
                 dst.speakers[i] = vstConfig.speakers[i];
 
             return *this;
@@ -207,17 +207,17 @@ struct SpeakerMappings  : private AudioChannelSet // (inheritance only to give e
             return *this;
         }
 
-        const Vst2::VstSpeakerArrangement& get() const { return *storage.get(); }
+        const Vst2::VstSpeakerConfiguration& get() const { return *storage.get(); }
 
     private:
         JUCE_LEAK_DETECTOR (VstSpeakerConfigurationHolder)
 
-        HeapBlock<Vst2::VstSpeakerArrangement> storage;
+        HeapBlock<Vst2::VstSpeakerConfiguration> storage;
 
-        Vst2::VstSpeakerArrangement* allocate (int numChannels)
+        Vst2::VstSpeakerConfiguration* allocate (int numChannels)
         {
-            auto arrangementSize = (size_t) (jmax (8, numChannels) - 8) * sizeof (Vst2::VstSpeakerProperties)
-                                    + sizeof (Vst2::VstSpeakerArrangement);
+            auto arrangementSize = (size_t) (jmax (8, numChannels) - 8) * sizeof (Vst2::VstIndividualSpeakerInfo)
+                                    + sizeof (Vst2::VstSpeakerConfiguration);
 
             storage.malloc (1, arrangementSize);
             return storage.get();
@@ -225,10 +225,10 @@ struct SpeakerMappings  : private AudioChannelSet // (inheritance only to give e
 
         void clear()
         {
-            Vst2::VstSpeakerArrangement& dst = *allocate (0);
+            Vst2::VstSpeakerConfiguration& dst = *allocate (0);
 
-            dst.type = Vst2::kSpeakerArrEmpty;
-            dst.numChannels = 0;
+            dst.type = Vst2::vstSpeakerConfigTypeEmpty;
+            dst.numberOfChannels = 0;
         }
     };
 
@@ -236,36 +236,36 @@ struct SpeakerMappings  : private AudioChannelSet // (inheritance only to give e
     {
         static const Mapping mappings[] =
         {
-            { Vst2::kSpeakerArrMono,           { centre, unknown } },
-            { Vst2::kSpeakerArrStereo,         { left, right, unknown } },
-            { Vst2::kSpeakerArrStereoSurround, { leftSurround, rightSurround, unknown } },
-            { Vst2::kSpeakerArrStereoCenter,   { leftCentre, rightCentre, unknown } },
-            { Vst2::kSpeakerArrStereoSide,     { leftSurroundRear, rightSurroundRear, unknown } },
-            { Vst2::kSpeakerArrStereoCLfe,     { centre, LFE, unknown } },
-            { Vst2::kSpeakerArr30Cine,         { left, right, centre, unknown } },
-            { Vst2::kSpeakerArr30Music,        { left, right, surround, unknown } },
-            { Vst2::kSpeakerArr31Cine,         { left, right, centre, LFE, unknown } },
-            { Vst2::kSpeakerArr31Music,        { left, right, LFE, surround, unknown } },
-            { Vst2::kSpeakerArr40Cine,         { left, right, centre, surround, unknown } },
-            { Vst2::kSpeakerArr40Music,        { left, right, leftSurround, rightSurround, unknown } },
-            { Vst2::kSpeakerArr41Cine,         { left, right, centre, LFE, surround, unknown } },
-            { Vst2::kSpeakerArr41Music,        { left, right, LFE, leftSurround, rightSurround, unknown } },
-            { Vst2::kSpeakerArr50,             { left, right, centre, leftSurround, rightSurround, unknown } },
-            { Vst2::kSpeakerArr51,             { left, right, centre, LFE, leftSurround, rightSurround, unknown } },
-            { Vst2::kSpeakerArr60Cine,         { left, right, centre, leftSurround, rightSurround, surround, unknown } },
-            { Vst2::kSpeakerArr60Music,        { left, right, leftSurround, rightSurround, leftSurroundRear, rightSurroundRear, unknown } },
-            { Vst2::kSpeakerArr61Cine,         { left, right, centre, LFE, leftSurround, rightSurround, surround, unknown } },
-            { Vst2::kSpeakerArr61Music,        { left, right, LFE, leftSurround, rightSurround, leftSurroundRear, rightSurroundRear, unknown } },
-            { Vst2::kSpeakerArr70Cine,         { left, right, centre, leftSurround, rightSurround, topFrontLeft, topFrontRight, unknown } },
-            { Vst2::kSpeakerArr70Music,        { left, right, centre, leftSurround, rightSurround, leftSurroundRear, rightSurroundRear, unknown } },
-            { Vst2::kSpeakerArr71Cine,         { left, right, centre, LFE, leftSurround, rightSurround, topFrontLeft, topFrontRight, unknown } },
-            { Vst2::kSpeakerArr71Music,        { left, right, centre, LFE, leftSurround, rightSurround, leftSurroundRear, rightSurroundRear, unknown } },
-            { Vst2::kSpeakerArr80Cine,         { left, right, centre, leftSurround, rightSurround, topFrontLeft, topFrontRight, surround, unknown } },
-            { Vst2::kSpeakerArr80Music,        { left, right, centre, leftSurround, rightSurround, surround, leftSurroundRear, rightSurroundRear, unknown } },
-            { Vst2::kSpeakerArr81Cine,         { left, right, centre, LFE, leftSurround, rightSurround, topFrontLeft, topFrontRight, surround, unknown } },
-            { Vst2::kSpeakerArr81Music,        { left, right, centre, LFE, leftSurround, rightSurround, surround, leftSurroundRear, rightSurroundRear, unknown } },
-            { Vst2::kSpeakerArr102,            { left, right, centre, LFE, leftSurround, rightSurround, topFrontLeft, topFrontCentre, topFrontRight, topRearLeft, topRearRight, LFE2, unknown } },
-            { Vst2::kSpeakerArrEmpty,          { unknown } }
+            { Vst2::vstSpeakerConfigTypeMono,                          { centre, unknown } },
+            { Vst2::vstSpeakerConfigTypeLR,                            { left, right, unknown } },
+            { Vst2::vstSpeakerConfigTypeLsRs,                          { leftSurround, rightSurround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLcRc,                          { leftCentre, rightCentre, unknown } },
+            { Vst2::vstSpeakerConfigTypeSlSr,                          { leftSurroundRear, rightSurroundRear, unknown } },
+            { Vst2::vstSpeakerConfigTypeCLfe,                          { centre, LFE, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRC,                           { left, right, centre, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRS,                           { left, right, surround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLfe,                        { left, right, centre, LFE, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRLfeS,                        { left, right, LFE, surround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCS,                          { left, right, centre, surround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRLsRs,                        { left, right, leftSurround, rightSurround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLfeS,                       { left, right, centre, LFE, surround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRLfeLsRs,                     { left, right, LFE, leftSurround, rightSurround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLsRs,                       { left, right, centre, leftSurround, rightSurround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLfeLsRs,                    { left, right, centre, LFE, leftSurround, rightSurround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLsRsCs,                     { left, right, centre, leftSurround, rightSurround, surround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRLsRsSlSr,                    { left, right, leftSurround, rightSurround, leftSurroundRear, rightSurroundRear, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLfeLsRsCs,                  { left, right, centre, LFE, leftSurround, rightSurround, surround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRLfeLsRsSlSr,                 { left, right, LFE, leftSurround, rightSurround, leftSurroundRear, rightSurroundRear, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLsRsLcRc,                   { left, right, centre, leftSurround, rightSurround, topFrontLeft, topFrontRight, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLsRsSlSr,                   { left, right, centre, leftSurround, rightSurround, leftSurroundRear, rightSurroundRear, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLfeLsRsLcRc,                { left, right, centre, LFE, leftSurround, rightSurround, topFrontLeft, topFrontRight, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLfeLsRsSlSr,                { left, right, centre, LFE, leftSurround, rightSurround, leftSurroundRear, rightSurroundRear, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLsRsLcRcCs,                 { left, right, centre, leftSurround, rightSurround, topFrontLeft, topFrontRight, surround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLsRsCsSlSr,                 { left, right, centre, leftSurround, rightSurround, surround, leftSurroundRear, rightSurroundRear, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLfeLsRsLcRcCs,              { left, right, centre, LFE, leftSurround, rightSurround, topFrontLeft, topFrontRight, surround, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLfeLsRsCsSlSr,              { left, right, centre, LFE, leftSurround, rightSurround, surround, leftSurroundRear, rightSurroundRear, unknown } },
+            { Vst2::vstSpeakerConfigTypeLRCLfeLsRsTflTfcTfrTrlTrrLfe2, { left, right, centre, LFE, leftSurround, rightSurround, topFrontLeft, topFrontCentre, topFrontRight, topRearLeft, topRearRight, LFE2, unknown } },
+            { Vst2::vstSpeakerConfigTypeEmpty,                         { unknown } }
         };
 
         return mappings;
@@ -275,25 +275,25 @@ struct SpeakerMappings  : private AudioChannelSet // (inheritance only to give e
     {
         static const std::map<AudioChannelSet::ChannelType, int32> speakerTypeMap =
         {
-            { AudioChannelSet::left,              Vst2::kSpeakerL },
-            { AudioChannelSet::right,             Vst2::kSpeakerR },
-            { AudioChannelSet::centre,            Vst2::kSpeakerC },
-            { AudioChannelSet::LFE,               Vst2::kSpeakerLfe },
-            { AudioChannelSet::leftSurround,      Vst2::kSpeakerLs },
-            { AudioChannelSet::rightSurround,     Vst2::kSpeakerRs },
-            { AudioChannelSet::leftCentre,        Vst2::kSpeakerLc },
-            { AudioChannelSet::rightCentre,       Vst2::kSpeakerRc },
-            { AudioChannelSet::surround,          Vst2::kSpeakerS },
-            { AudioChannelSet::leftSurroundRear,  Vst2::kSpeakerSl },
-            { AudioChannelSet::rightSurroundRear, Vst2::kSpeakerSr },
-            { AudioChannelSet::topMiddle,         Vst2::kSpeakerTm },
-            { AudioChannelSet::topFrontLeft,      Vst2::kSpeakerTfl },
-            { AudioChannelSet::topFrontCentre,    Vst2::kSpeakerTfc },
-            { AudioChannelSet::topFrontRight,     Vst2::kSpeakerTfr },
-            { AudioChannelSet::topRearLeft,       Vst2::kSpeakerTrl },
-            { AudioChannelSet::topRearCentre,     Vst2::kSpeakerTrc },
-            { AudioChannelSet::topRearRight,      Vst2::kSpeakerTrr },
-            { AudioChannelSet::LFE2,              Vst2::kSpeakerLfe2 }
+            { AudioChannelSet::left,              Vst2::vstIndividualSpeakerTypeLeft },
+            { AudioChannelSet::right,             Vst2::vstIndividualSpeakerTypeRight },
+            { AudioChannelSet::centre,            Vst2::vstIndividualSpeakerTypeCentre },
+            { AudioChannelSet::LFE,               Vst2::vstIndividualSpeakerTypeLFE },
+            { AudioChannelSet::leftSurround,      Vst2::vstIndividualSpeakerTypeLeftSurround },
+            { AudioChannelSet::rightSurround,     Vst2::vstIndividualSpeakerTypeRightSurround },
+            { AudioChannelSet::leftCentre,        Vst2::vstIndividualSpeakerTypeLeftCentre },
+            { AudioChannelSet::rightCentre,       Vst2::vstIndividualSpeakerTypeRightCentre },
+            { AudioChannelSet::surround,          Vst2::vstIndividualSpeakerTypeSurround },
+            { AudioChannelSet::leftSurroundRear,  Vst2::vstIndividualSpeakerTypeLeftRearSurround },
+            { AudioChannelSet::rightSurroundRear, Vst2::vstIndividualSpeakerTypeRightRearSurround },
+            { AudioChannelSet::topMiddle,         Vst2::vstIndividualSpeakerTypeTopMiddle },
+            { AudioChannelSet::topFrontLeft,      Vst2::vstIndividualSpeakerTypeTopFrontLeft },
+            { AudioChannelSet::topFrontCentre,    Vst2::vstIndividualSpeakerTypeTopFrontCentre },
+            { AudioChannelSet::topFrontRight,     Vst2::vstIndividualSpeakerTypeTopFrontRight },
+            { AudioChannelSet::topRearLeft,       Vst2::vstIndividualSpeakerTypeTopRearLeft },
+            { AudioChannelSet::topRearCentre,     Vst2::vstIndividualSpeakerTypeTopRearCentre },
+            { AudioChannelSet::topRearRight,      Vst2::vstIndividualSpeakerTypeTopRearRight },
+            { AudioChannelSet::LFE2,              Vst2::vstIndividualSpeakerTypeLFE2 }
         };
 
         if (speakerTypeMap.find (type) == speakerTypeMap.end())
@@ -306,25 +306,25 @@ struct SpeakerMappings  : private AudioChannelSet // (inheritance only to give e
     {
         switch (type)
         {
-            case Vst2::kSpeakerL:      return AudioChannelSet::left;
-            case Vst2::kSpeakerR:      return AudioChannelSet::right;
-            case Vst2::kSpeakerC:      return AudioChannelSet::centre;
-            case Vst2::kSpeakerLfe:    return AudioChannelSet::LFE;
-            case Vst2::kSpeakerLs:     return AudioChannelSet::leftSurround;
-            case Vst2::kSpeakerRs:     return AudioChannelSet::rightSurround;
-            case Vst2::kSpeakerLc:     return AudioChannelSet::leftCentre;
-            case Vst2::kSpeakerRc:     return AudioChannelSet::rightCentre;
-            case Vst2::kSpeakerS:      return AudioChannelSet::surround;
-            case Vst2::kSpeakerSl:     return AudioChannelSet::leftSurroundRear;
-            case Vst2::kSpeakerSr:     return AudioChannelSet::rightSurroundRear;
-            case Vst2::kSpeakerTm:     return AudioChannelSet::topMiddle;
-            case Vst2::kSpeakerTfl:    return AudioChannelSet::topFrontLeft;
-            case Vst2::kSpeakerTfc:    return AudioChannelSet::topFrontCentre;
-            case Vst2::kSpeakerTfr:    return AudioChannelSet::topFrontRight;
-            case Vst2::kSpeakerTrl:    return AudioChannelSet::topRearLeft;
-            case Vst2::kSpeakerTrc:    return AudioChannelSet::topRearCentre;
-            case Vst2::kSpeakerTrr:    return AudioChannelSet::topRearRight;
-            case Vst2::kSpeakerLfe2:   return AudioChannelSet::LFE2;
+            case Vst2::vstIndividualSpeakerTypeLeft:                 return AudioChannelSet::left;
+            case Vst2::vstIndividualSpeakerTypeRight:                return AudioChannelSet::right;
+            case Vst2::vstIndividualSpeakerTypeCentre:               return AudioChannelSet::centre;
+            case Vst2::vstIndividualSpeakerTypeLFE:                  return AudioChannelSet::LFE;
+            case Vst2::vstIndividualSpeakerTypeLeftSurround:         return AudioChannelSet::leftSurround;
+            case Vst2::vstIndividualSpeakerTypeRightSurround:        return AudioChannelSet::rightSurround;
+            case Vst2::vstIndividualSpeakerTypeLeftCentre:           return AudioChannelSet::leftCentre;
+            case Vst2::vstIndividualSpeakerTypeRightCentre:          return AudioChannelSet::rightCentre;
+            case Vst2::vstIndividualSpeakerTypeSurround:             return AudioChannelSet::surround;
+            case Vst2::vstIndividualSpeakerTypeLeftRearSurround:     return AudioChannelSet::leftSurroundRear;
+            case Vst2::vstIndividualSpeakerTypeRightRearSurround:    return AudioChannelSet::rightSurroundRear;
+            case Vst2::vstIndividualSpeakerTypeTopMiddle:            return AudioChannelSet::topMiddle;
+            case Vst2::vstIndividualSpeakerTypeTopFrontLeft:         return AudioChannelSet::topFrontLeft;
+            case Vst2::vstIndividualSpeakerTypeTopFrontCentre:       return AudioChannelSet::topFrontCentre;
+            case Vst2::vstIndividualSpeakerTypeTopFrontRight:        return AudioChannelSet::topFrontRight;
+            case Vst2::vstIndividualSpeakerTypeTopRearLeft:          return AudioChannelSet::topRearLeft;
+            case Vst2::vstIndividualSpeakerTypeTopRearCentre:        return AudioChannelSet::topRearCentre;
+            case Vst2::vstIndividualSpeakerTypeTopRearRight:         return AudioChannelSet::topRearRight;
+            case Vst2::vstIndividualSpeakerTypeLFE2:                 return AudioChannelSet::LFE2;
             default: break;
         }
 
diff --git a/modules/juce_audio_processors/format_types/juce_VSTInterface.h b/modules/juce_audio_processors/format_types/juce_VSTInterface.h
new file mode 100644
index 000000000..a2f09aae9
--- /dev/null
+++ b/modules/juce_audio_processors/format_types/juce_VSTInterface.h
@@ -0,0 +1,529 @@
+/*
+  ==============================================================================
+
+   This file is part of the JUCE library.
+   Copyright (c) 2017 - ROLI Ltd.
+
+   JUCE is an open source library subject to commercial or open-source
+   licensing.
+
+   By using JUCE, you agree to the terms of both the JUCE 5 End-User License
+   Agreement and JUCE 5 Privacy Policy (both updated and effective as of the
+   27th April 2017).
+
+   End User License Agreement: www.juce.com/juce-5-licence
+   Privacy Policy: www.juce.com/juce-5-privacy-policy
+
+   Or: You may also use this code under the terms of the GPL v3 (see
+   www.gnu.org/licenses).
+
+   JUCE IS PROVIDED "AS IS" WITHOUT ANY WARRANTY, AND ALL WARRANTIES, WHETHER
+   EXPRESSED OR IMPLIED, INCLUDING MERCHANTABILITY AND FITNESS FOR PURPOSE, ARE
+   DISCLAIMED.
+
+  ==============================================================================
+*/
+
+#define JUCE_VSTINTERFACE_H_INCLUDED
+
+using namespace juce;
+
+#if JUCE_MSVC
+ #define VSTINTERFACECALL __cdecl
+ #pragma pack(push)
+ #pragma pack(8)
+#elif JUCE_MAC || JUCE_IOS
+ #define VSTINTERFACECALL
+ #if JUCE_64BIT
+  #pragma options align=power
+ #else
+  #pragma options align=mac68k
+ #endif
+#else
+ #define VSTINTERFACECALL
+ #pragma pack(push, 8)
+#endif
+
+const int32 juceVstInterfaceVersion = 2400;
+const int32 juceVstInterfaceIdentifier = 0x56737450;    // The "magic" identifier in the SDK is 'VstP'.
+
+//==============================================================================
+/** Structure used for VSTs
+
+    @tags{Audio}
+*/
+struct VstEffectInterface
+{
+    int32 interfaceIdentifier;
+    pointer_sized_int (VSTINTERFACECALL* dispatchFunction)          (VstEffectInterface*, int32 op, int32 index, pointer_sized_int value, void* ptr, float opt);
+    void              (VSTINTERFACECALL* processAudioFunction)      (VstEffectInterface*, float** inputs, float** outputs, int32 numSamples);
+    void              (VSTINTERFACECALL* setParameterValueFunction) (VstEffectInterface*, int32 parameterIndex, float value);
+    float             (VSTINTERFACECALL* getParameterValueFunction) (VstEffectInterface*, int32 parameterIndex);
+    int32 numPrograms;
+    int32 numParameters;
+    int32 numInputChannels;
+    int32 numOutputChannels;
+    int32 flags;
+    pointer_sized_int hostSpace1;
+    pointer_sized_int hostSpace2;
+    int32 latency;
+    int32 deprecated1;
+    int32 deprecated2;
+    float deprecated3;
+    void* effectPointer;
+    void* userPointer;
+    int32 plugInIdentifier;
+    int32 plugInVersion;
+    void (VSTINTERFACECALL* processAudioInplaceFunction)       (VstEffectInterface*, float**  inputs, float**  outputs, int32 numSamples);
+    void (VSTINTERFACECALL* processDoubleAudioInplaceFunction) (VstEffectInterface*, double** inputs, double** outputs, int32 numSamples);
+    char emptySpace[56];
+};
+
+typedef pointer_sized_int (VSTINTERFACECALL* VstHostCallback) (VstEffectInterface*, int32 op, int32 index, pointer_sized_int value, void* ptr, float opt);
+
+enum VstEffectInterfaceFlags
+{
+    vstEffectFlagHasEditor          = 1,
+    vstEffectFlagInplaceAudio       = 16,
+    vstEffectFlagDataInChunks       = 32,
+    vstEffectFlagIsSynth            = 256,
+    vstEffectFlagInplaceDoubleAudio = 4096
+};
+
+//==============================================================================
+enum VstHostToPlugInOpcodes
+{
+    plugInOpcodeOpen,
+    plugInOpcodeClose,
+    plugInOpcodeSetCurrentProgram,
+    plugInOpcodeGetCurrentProgram,
+    plugInOpcodeSetCurrentProgramName,
+    plugInOpcodeGetCurrentProgramName,
+    plugInOpcodeGetParameterLabel,
+    plugInOpcodeGetParameterText,
+    plugInOpcodeGetParameterName,
+    plugInOpcodeSetSampleRate = plugInOpcodeGetParameterName + 2,
+    plugInOpcodeSetBlockSize,
+    plugInOpcodeResumeSuspend,
+    plugInOpcodeGetEditorBounds,
+    plugInOpcodeOpenEditor,
+    plugInOpcodeCloseEditor,
+    plugInOpcodeDrawEditor,
+    plugInOpcodeGetMouse,
+    plugInOpcodeEditorIdle = plugInOpcodeGetMouse + 2,
+    plugInOpcodeeffEditorTop,
+    plugInOpcodeSleepEditor,
+    plugInOpcodeIdentify,
+    plugInOpcodeGetData,
+    plugInOpcodeSetData,
+    plugInOpcodePreAudioProcessingEvents,
+    plugInOpcodeIsParameterAutomatable,
+    plugInOpcodeParameterValueForText,
+    plugInOpcodeGetProgramName = plugInOpcodeParameterValueForText + 2,
+    plugInOpcodeConnectInput = plugInOpcodeGetProgramName + 2,
+    plugInOpcodeConnectOutput,
+    plugInOpcodeGetInputPinProperties,
+    plugInOpcodeGetOutputPinProperties,
+    plugInOpcodeGetPlugInCategory,
+    plugInOpcodeSetSpeakerConfiguration = plugInOpcodeGetPlugInCategory + 7,
+    plugInOpcodeSetBypass = plugInOpcodeSetSpeakerConfiguration + 2,
+    plugInOpcodeGetPlugInName,
+    plugInOpcodeGetManufacturerName = plugInOpcodeGetPlugInName + 2,
+    plugInOpcodeGetManufacturerProductName,
+    plugInOpcodeGetManufacturerVersion,
+    plugInOpcodeManufacturerSpecific,
+    plugInOpcodeCanPlugInDo,
+    plugInOpcodeGetTailSize,
+    plugInOpcodeIdle,
+    plugInOpcodeKeyboardFocusRequired = plugInOpcodeIdle + 4,
+    plugInOpcodeGetVstInterfaceVersion,
+    plugInOpcodeGetCurrentMidiProgram = plugInOpcodeGetVstInterfaceVersion + 5,
+    plugInOpcodeGetSpeakerArrangement = plugInOpcodeGetCurrentMidiProgram + 6,
+    plugInOpcodeNextPlugInUniqueID,
+    plugInOpcodeStartProcess,
+    plugInOpcodeStopProcess,
+    plugInOpcodeSetNumberOfSamplesToProcess,
+    plugInOpcodeSetSampleFloatType = plugInOpcodeSetNumberOfSamplesToProcess + 4,
+    pluginOpcodeGetNumMidiInputChannels,
+    pluginOpcodeGetNumMidiOutputChannels,
+    plugInOpcodeMaximum = pluginOpcodeGetNumMidiOutputChannels
+};
+
+
+enum VstPlugInToHostOpcodes
+{
+    hostOpcodeParameterChanged,
+    hostOpcodeVstVersion,
+    hostOpcodeCurrentId,
+    hostOpcodeIdle,
+    hostOpcodePinConnected,
+    hostOpcodePlugInWantsMidi = hostOpcodePinConnected + 2,
+    hostOpcodeGetTimingInfo,
+    hostOpcodePreAudioProcessingEvents,
+    hostOpcodeSetTime,
+    hostOpcodeTempoAt,
+    hostOpcodeGetNumberOfAutomatableParameters,
+    hostOpcodeGetParameterInterval,
+    hostOpcodeIOModified,
+    hostOpcodeNeedsIdle,
+    hostOpcodeWindowSize,
+    hostOpcodeGetSampleRate,
+    hostOpcodeGetBlockSize,
+    hostOpcodeGetInputLatency,
+    hostOpcodeGetOutputLatency,
+    hostOpcodeGetPreviousPlugIn,
+    hostOpcodeGetNextPlugIn,
+    hostOpcodeWillReplace,
+    hostOpcodeGetCurrentAudioProcessingLevel,
+    hostOpcodeGetAutomationState,
+    hostOpcodeOfflineStart,
+    hostOpcodeOfflineReadSource,
+    hostOpcodeOfflineWrite,
+    hostOpcodeOfflineGetCurrentPass,
+    hostOpcodeOfflineGetCurrentMetaPass,
+    hostOpcodeSetOutputSampleRate,
+    hostOpcodeGetOutputSpeakerConfiguration,
+    hostOpcodeGetManufacturerName,
+    hostOpcodeGetProductName,
+    hostOpcodeGetManufacturerVersion,
+    hostOpcodeManufacturerSpecific,
+    hostOpcodeSetIcon,
+    hostOpcodeCanHostDo,
+    hostOpcodeGetLanguage,
+    hostOpcodeOpenEditorWindow,
+    hostOpcodeCloseEditorWindow,
+    hostOpcodeGetDirectory,
+    hostOpcodeUpdateView,
+    hostOpcodeParameterChangeGestureBegin,
+    hostOpcodeParameterChangeGestureEnd,
+};
+
+//==============================================================================
+enum VstProcessingSampleType
+{
+    vstProcessingSampleTypeFloat,
+    vstProcessingSampleTypeDouble
+};
+
+//==============================================================================
+// These names must be identical to the Steinberg SDK so JUCE users can set
+// exactly what they want.
+enum VstPlugInCategory
+{
+    kPlugCategUnknown,
+    kPlugCategEffect,
+    kPlugCategSynth,
+    kPlugCategAnalysis,
+    kPlugCategMastering,
+    kPlugCategSpacializer,
+    kPlugCategRoomFx,
+    kPlugSurroundFx,
+    kPlugCategRestoration,
+    kPlugCategOfflineProcess,
+    kPlugCategShell,
+    kPlugCategGenerator
+};
+
+//==============================================================================
+/** Structure used for VSTs
+
+    @tags{Audio}
+*/
+struct VstEditorBounds
+{
+    int16 upper;
+    int16 leftmost;
+    int16 lower;
+    int16 rightmost;
+};
+
+//==============================================================================
+enum VstMaxStringLengths
+{
+    vstMaxNameLength                     = 64,
+    vstMaxParameterOrPinLabelLength      = 64,
+    vstMaxParameterOrPinShortLabelLength = 8,
+    vstMaxCategoryLength                 = 24,
+    vstMaxManufacturerStringLength       = 64,
+    vstMaxPlugInNameStringLength         = 64
+};
+
+//==============================================================================
+/** Structure used for VSTs
+
+    @tags{Audio}
+*/
+struct VstPinInfo
+{
+    char text[vstMaxParameterOrPinLabelLength];
+    int32 flags;
+    int32 configurationType;
+    char shortText[vstMaxParameterOrPinShortLabelLength];
+    char unused[48];
+};
+
+enum VstPinInfoFlags
+{
+    vstPinInfoFlagIsActive = 1,
+    vstPinInfoFlagIsStereo = 2,
+    vstPinInfoFlagValid    = 4
+};
+
+//==============================================================================
+/** Structure used for VSTs
+
+    @tags{Audio}
+*/
+struct VstEvent
+{
+    int32 type;
+    int32 size;
+    int32 sampleOffset;
+    int32 flags;
+    char content[16];
+};
+
+enum VstEventTypes
+{
+    vstMidiEventType  = 1,
+    vstSysExEventType = 6
+};
+
+/** Structure used for VSTs
+
+    @tags{Audio}
+*/
+struct VstEventBlock
+{
+    int32 numberOfEvents;
+    pointer_sized_int future;
+    VstEvent* events[2];
+};
+
+/** Structure used for VSTs
+
+    @tags{Audio}
+*/
+struct VstMidiEvent
+{
+    int32 type;
+    int32 size;
+    int32 sampleOffset;
+    int32 flags;
+    int32 noteSampleLength;
+    int32 noteSampleOffset;
+    char midiData[4];
+    char tuning;
+    char noteVelocityOff;
+    char future1;
+    char future2;
+};
+
+enum VstMidiEventFlags
+{
+    vstMidiEventIsRealtime = 1
+};
+
+/** Structure used for VSTs
+
+    @tags{Audio}
+*/
+struct VstSysExEvent
+{
+    int32 type;
+    int32 size;
+    int32 offsetSamples;
+    int32 flags;
+    int32 sysExDumpSize;
+    pointer_sized_int future1;
+    char* sysExDump;
+    pointer_sized_int future2;
+};
+
+//==============================================================================
+/** Structure used for VSTs
+
+    @tags{Audio}
+*/
+struct VstTimingInformation
+{
+    double samplePosition;
+    double sampleRate;
+    double systemTimeNanoseconds;
+    double musicalPosition;
+    double tempoBPM;
+    double lastBarPosition;
+    double loopStartPosition;
+    double loopEndPosition;
+    int32 timeSignatureNumerator;
+    int32 timeSignatureDenominator;
+    int32 smpteOffset;
+    int32 smpteRate;
+    int32 samplesToNearestClock;
+    int32 flags;
+};
+
+enum VstTimingInformationFlags
+{
+    vstTimingInfoFlagTransportChanged          = 1,
+    vstTimingInfoFlagCurrentlyPlaying          = 2,
+    vstTimingInfoFlagLoopActive                = 4,
+    vstTimingInfoFlagCurrentlyRecording        = 8,
+    vstTimingInfoFlagAutomationWriteModeActive = 64,
+    vstTimingInfoFlagAutomationReadModeActive  = 128,
+    vstTimingInfoFlagNanosecondsValid          = 256,
+    vstTimingInfoFlagMusicalPositionValid      = 512,
+    vstTimingInfoFlagTempoValid                = 1024,
+    vstTimingInfoFlagLastBarPositionValid      = 2048,
+    vstTimingInfoFlagLoopPositionValid         = 4096,
+    vstTimingInfoFlagTimeSignatureValid        = 8192,
+    vstTimingInfoFlagSmpteValid                = 16384,
+    vstTimingInfoFlagNearestClockValid         = 32768
+};
+
+//==============================================================================
+enum VstSmpteRates
+{
+    vstSmpteRateFps24,
+    vstSmpteRateFps25,
+    vstSmpteRateFps2997,
+    vstSmpteRateFps30,
+    vstSmpteRateFps2997drop,
+    vstSmpteRateFps30drop,
+
+    vstSmpteRate16mmFilm,
+    vstSmpteRate35mmFilm,
+
+    vstSmpteRateFps239 = vstSmpteRate35mmFilm + 3,
+    vstSmpteRateFps249 ,
+    vstSmpteRateFps599,
+    vstSmpteRateFps60
+};
+
+//==============================================================================
+/** Structure used for VSTs
+
+    @tags{Audio}
+*/
+struct VstIndividualSpeakerInfo
+{
+    float azimuthalAngle;
+    float elevationAngle;
+    float radius;
+    float reserved;
+    char label[vstMaxNameLength];
+    int32 type;
+    char unused[28];
+};
+
+enum VstIndividualSpeakerType
+{
+    vstIndividualSpeakerTypeUndefined = 0x7fffffff,
+    vstIndividualSpeakerTypeMono = 0,
+    vstIndividualSpeakerTypeLeft,
+    vstIndividualSpeakerTypeRight,
+    vstIndividualSpeakerTypeCentre,
+    vstIndividualSpeakerTypeLFE,
+    vstIndividualSpeakerTypeLeftSurround,
+    vstIndividualSpeakerTypeRightSurround,
+    vstIndividualSpeakerTypeLeftCentre,
+    vstIndividualSpeakerTypeRightCentre,
+    vstIndividualSpeakerTypeSurround,
+    vstIndividualSpeakerTypeCentreSurround = vstIndividualSpeakerTypeSurround,
+    vstIndividualSpeakerTypeLeftRearSurround,
+    vstIndividualSpeakerTypeRightRearSurround,
+    vstIndividualSpeakerTypeTopMiddle,
+    vstIndividualSpeakerTypeTopFrontLeft,
+    vstIndividualSpeakerTypeTopFrontCentre,
+    vstIndividualSpeakerTypeTopFrontRight,
+    vstIndividualSpeakerTypeTopRearLeft,
+    vstIndividualSpeakerTypeTopRearCentre,
+    vstIndividualSpeakerTypeTopRearRight,
+    vstIndividualSpeakerTypeLFE2
+};
+
+/** Structure used for VSTs
+
+    @tags{Audio}
+*/
+struct VstSpeakerConfiguration
+{
+    int32 type;
+    int32 numberOfChannels;
+    VstIndividualSpeakerInfo speakers[8];
+};
+
+enum VstSpeakerConfigurationType
+{
+    vstSpeakerConfigTypeUser  = -2,
+    vstSpeakerConfigTypeEmpty = -1,
+    vstSpeakerConfigTypeMono  = 0,
+    vstSpeakerConfigTypeLR,
+    vstSpeakerConfigTypeLsRs,
+    vstSpeakerConfigTypeLcRc,
+    vstSpeakerConfigTypeSlSr,
+    vstSpeakerConfigTypeCLfe,
+    vstSpeakerConfigTypeLRC,
+    vstSpeakerConfigTypeLRS,
+    vstSpeakerConfigTypeLRCLfe,
+    vstSpeakerConfigTypeLRLfeS,
+    vstSpeakerConfigTypeLRCS,
+    vstSpeakerConfigTypeLRLsRs,
+    vstSpeakerConfigTypeLRCLfeS,
+    vstSpeakerConfigTypeLRLfeLsRs,
+    vstSpeakerConfigTypeLRCLsRs,
+    vstSpeakerConfigTypeLRCLfeLsRs,
+    vstSpeakerConfigTypeLRCLsRsCs,
+    vstSpeakerConfigTypeLRLsRsSlSr,
+    vstSpeakerConfigTypeLRCLfeLsRsCs,
+    vstSpeakerConfigTypeLRLfeLsRsSlSr,
+    vstSpeakerConfigTypeLRCLsRsLcRc,
+    vstSpeakerConfigTypeLRCLsRsSlSr,
+    vstSpeakerConfigTypeLRCLfeLsRsLcRc,
+    vstSpeakerConfigTypeLRCLfeLsRsSlSr,
+    vstSpeakerConfigTypeLRCLsRsLcRcCs,
+    vstSpeakerConfigTypeLRCLsRsCsSlSr,
+    vstSpeakerConfigTypeLRCLfeLsRsLcRcCs,
+    vstSpeakerConfigTypeLRCLfeLsRsCsSlSr,
+    vstSpeakerConfigTypeLRCLfeLsRsTflTfcTfrTrlTrrLfe2
+};
+
+#if JUCE_BIG_ENDIAN
+ #define JUCE_MULTICHAR_CONSTANT(a, b, c, d) (a | (((uint32) b) << 8) | (((uint32) c) << 16) | (((uint32) d) << 24))
+#else
+ #define JUCE_MULTICHAR_CONSTANT(a, b, c, d) (d | (((uint32) c) << 8) | (((uint32) b) << 16) | (((uint32) a) << 24))
+#endif
+
+enum PresonusExtensionConstants
+{
+    presonusVendorID                = JUCE_MULTICHAR_CONSTANT ('P', 'r', 'e', 'S'),
+    presonusSetContentScaleFactor   = JUCE_MULTICHAR_CONSTANT ('A', 'e', 'C', 's')
+};
+
+//==============================================================================
+/** Structure used for VSTs
+
+    @tags{Audio}
+*/
+struct vst2FxBank
+{
+    int32 magic1;
+    int32 size;
+    int32 magic2;
+    int32 version1;
+    int32 fxID;
+    int32 version2;
+    int32 elements;
+    int32 current;
+    char shouldBeZero[124];
+    int32 chunkSize;
+    char chunk[1];
+};
+
+#if JUCE_MSVC
+ #pragma pack(pop)
+#elif JUCE_MAC || JUCE_IOS
+ #pragma options align=reset
+#else
+ #pragma pack(pop)
+#endif
diff --git a/modules/juce_audio_processors/format_types/juce_VSTMidiEventList.h b/modules/juce_audio_processors/format_types/juce_VSTMidiEventList.h
index 85c163d59..a39d22f93 100644
--- a/modules/juce_audio_processors/format_types/juce_VSTMidiEventList.h
+++ b/modules/juce_audio_processors/format_types/juce_VSTMidiEventList.h
@@ -50,7 +50,7 @@ public:
         numEventsUsed = 0;
 
         if (events != nullptr)
-            events->numEvents = 0;
+            events->numberOfEvents = 0;
     }
 
     void addEvent (const void* const midiData, int numBytes, int frameOffset)
@@ -59,50 +59,50 @@ public:
 
         void* const ptr = (Vst2::VstMidiEvent*) (events->events [numEventsUsed]);
         auto* const e = (Vst2::VstMidiEvent*) ptr;
-        events->numEvents = ++numEventsUsed;
+        events->numberOfEvents = ++numEventsUsed;
 
         if (numBytes <= 4)
         {
-            if (e->type == Vst2::kVstSysExType)
+            if (e->type == Vst2::vstSysExEventType)
             {
-                delete[] (((Vst2::VstMidiSysexEvent*) ptr)->sysexDump);
-                e->type = Vst2::kVstMidiType;
-                e->byteSize = sizeof (Vst2::VstMidiEvent);
-                e->noteLength = 0;
-                e->noteOffset = 0;
-                e->detune = 0;
-                e->noteOffVelocity = 0;
+                delete[] (((Vst2::VstSysExEvent*) ptr)->sysExDump);
+                e->type = Vst2::vstMidiEventType;
+                e->size = sizeof (Vst2::VstMidiEvent);
+                e->noteSampleLength = 0;
+                e->noteSampleOffset = 0;
+                e->tuning = 0;
+                e->noteVelocityOff = 0;
             }
 
-            e->deltaFrames = frameOffset;
+            e->sampleOffset = frameOffset;
             memcpy (e->midiData, midiData, (size_t) numBytes);
         }
         else
         {
-            auto* const se = (Vst2::VstMidiSysexEvent*) ptr;
+            auto* const se = (Vst2::VstSysExEvent*) ptr;
 
-            if (se->type == Vst2::kVstSysExType)
-                delete[] se->sysexDump;
+            if (se->type == Vst2::vstSysExEventType)
+                delete[] se->sysExDump;
 
-            se->sysexDump = new char [(size_t) numBytes];
-            memcpy (se->sysexDump, midiData, (size_t) numBytes);
+            se->sysExDump = new char [(size_t) numBytes];
+            memcpy (se->sysExDump, midiData, (size_t) numBytes);
 
-            se->type = Vst2::kVstSysExType;
-            se->byteSize = sizeof (Vst2::VstMidiSysexEvent);
-            se->deltaFrames = frameOffset;
+            se->type = Vst2::vstSysExEventType;
+            se->size = sizeof (Vst2::VstSysExEvent);
+            se->offsetSamples = frameOffset;
             se->flags = 0;
-            se->dumpBytes = numBytes;
-            se->resvd1 = 0;
-            se->resvd2 = 0;
+            se->sysExDumpSize = numBytes;
+            se->future1 = 0;
+            se->future2 = 0;
         }
     }
 
     //==============================================================================
     // Handy method to pull the events out of an event buffer supplied by the host
     // or plugin.
-    static void addEventsToMidiBuffer (const Vst2::VstEvents* events, MidiBuffer& dest)
+    static void addEventsToMidiBuffer (const Vst2::VstEventBlock* events, MidiBuffer& dest)
     {
-        for (int i = 0; i < events->numEvents; ++i)
+        for (int i = 0; i < events->numberOfEvents; ++i)
         {
             const Vst2::VstEvent* const e = events->events[i];
 
@@ -110,17 +110,17 @@ public:
             {
                 const void* const ptr = events->events[i];
 
-                if (e->type == Vst2::kVstMidiType)
+                if (e->type == Vst2::vstMidiEventType)
                 {
                     dest.addEvent ((const juce::uint8*) ((const Vst2::VstMidiEvent*) ptr)->midiData,
-                                   4, e->deltaFrames);
+                                   4, e->sampleOffset);
                 }
-                else if (e->type == Vst2::kVstSysExType)
+                else if (e->type == Vst2::vstSysExEventType)
                 {
-                    const auto* se = (const Vst2::VstMidiSysexEvent*) ptr;
-                    dest.addEvent ((const juce::uint8*) se->sysexDump,
-                                   (int) se->dumpBytes,
-                                   e->deltaFrames);
+                    const auto* se = (const Vst2::VstSysExEvent*) ptr;
+                    dest.addEvent ((const juce::uint8*) se->sysExDump,
+                                   (int) se->sysExDumpSize,
+                                   e->sampleOffset);
                 }
             }
         }
@@ -161,25 +161,25 @@ public:
     }
 
     //==============================================================================
-    HeapBlock<Vst2::VstEvents> events;
+    HeapBlock<Vst2::VstEventBlock> events;
 
 private:
     int numEventsUsed, numEventsAllocated;
 
     static Vst2::VstEvent* allocateVSTEvent()
     {
-        auto e = (Vst2::VstEvent*) std::calloc (1, sizeof (Vst2::VstMidiEvent) > sizeof (Vst2::VstMidiSysexEvent) ? sizeof (Vst2::VstMidiEvent)
-                                                                                            : sizeof (Vst2::VstMidiSysexEvent));
-        e->type = Vst2::kVstMidiType;
-        e->byteSize = sizeof (Vst2::VstMidiEvent);
+        auto e = (Vst2::VstEvent*) std::calloc (1, sizeof (Vst2::VstMidiEvent) > sizeof (Vst2::VstSysExEvent) ? sizeof (Vst2::VstMidiEvent)
+                                                                                            : sizeof (Vst2::VstSysExEvent));
+        e->type = Vst2::vstMidiEventType;
+        e->size = sizeof (Vst2::VstMidiEvent);
         return e;
     }
 
     static void freeVSTEvent (Vst2::VstEvent* e)
     {
-        if (e->type == Vst2::kVstSysExType)
+        if (e->type == Vst2::vstSysExEventType)
         {
-            delete[] (reinterpret_cast<Vst2::VstMidiSysexEvent*> (e)->sysexDump);
+            delete[] (reinterpret_cast<Vst2::VstSysExEvent*> (e)->sysExDump);
         }
 
         std::free (e);
diff --git a/modules/juce_audio_processors/format_types/juce_VSTPluginFormat.cpp b/modules/juce_audio_processors/format_types/juce_VSTPluginFormat.cpp
index bdb285290..7dff1e70f 100644
--- a/modules/juce_audio_processors/format_types/juce_VSTPluginFormat.cpp
+++ b/modules/juce_audio_processors/format_types/juce_VSTPluginFormat.cpp
@@ -30,7 +30,6 @@ JUCE_BEGIN_IGNORE_WARNINGS_GCC_LIKE ("-Wzero-as-null-pointer-constant")
 JUCE_BEGIN_IGNORE_WARNINGS_MSVC (4996)
 
 #define VST_FORCE_DEPRECATED 0
-#define JUCE_VSTINTERFACE_H_INCLUDED 1
 
 namespace Vst2
 {
@@ -39,8 +38,7 @@ namespace Vst2
 // paths or use the "VST (Legacy) SDK Folder" field in the Projucer. The VST2
 // SDK can be obtained from the vstsdk3610_11_06_2018_build_37 (or older) VST3
 // SDK or JUCE version 5.3.2.
-#include <pluginterfaces/vst2.x/aeffect.h>
-#include <pluginterfaces/vst2.x/aeffectx.h>
+#include "../../juce_audio_processors/format_types/juce_VSTInterface.h"
 }
 
 #include "juce_VSTCommon.h"
@@ -66,7 +64,7 @@ JUCE_BEGIN_IGNORE_WARNINGS_MSVC (4355)
 #endif
 
 #ifndef JUCE_VST_WRAPPER_INVOKE_MAIN
-#define JUCE_VST_WRAPPER_INVOKE_MAIN  effect = module->moduleMain ((Vst2::audioMasterCallback) &audioMaster);
+ #define JUCE_VST_WRAPPER_INVOKE_MAIN  effect = module->moduleMain (&audioMaster);
 #endif
 
 //==============================================================================
@@ -206,8 +204,8 @@ namespace
 }
 
 //==============================================================================
-typedef Vst2::AEffect* (VSTCALLBACK *MainCall) (Vst2::audioMasterCallback);
-static pointer_sized_int VSTCALLBACK audioMaster (Vst2::AEffect*, int32, int32, pointer_sized_int, void*, float);
+typedef Vst2::VstEffectInterface* (VSTINTERFACECALL *MainCall) (Vst2::VstHostCallback);
+static pointer_sized_int VSTINTERFACECALL audioMaster (Vst2::VstEffectInterface*, int32, int32, pointer_sized_int, void*, float);
 
 //==============================================================================
 // Change this to disable logging of various VST activities
@@ -675,9 +673,9 @@ struct ModuleHandle    : public ReferenceCountedObject
         module.close();
     }
 
-    void closeEffect (Vst2::AEffect* eff)
+    void closeEffect (Vst2::VstEffectInterface* eff)
     {
-        eff->dispatcher (eff, Vst2::effClose, 0, 0, nullptr, 0);
+        eff->dispatchFunction (eff, Vst2::plugInOpcodeClose, 0, 0, nullptr, 0);
     }
 
    #if JUCE_WINDOWS
@@ -801,9 +799,9 @@ struct ModuleHandle    : public ReferenceCountedObject
         }
     }
 
-    void closeEffect (Vst2::AEffect* eff)
+    void closeEffect (Vst2::VstEffectInterface* eff)
     {
-        eff->dispatcher (eff, Vst2::effClose, 0, 0, nullptr, 0);
+        eff->dispatchFunction (eff, Vst2::plugInOpcodeClose, 0, 0, nullptr, 0);
     }
 
   #endif
@@ -855,7 +853,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
             {
                 const ScopedLock sl (pluginInstance.lock);
 
-                return effect->getParameter (effect, getParameterIndex());
+                return effect->getParameterValueFunction (effect, getParameterIndex());
             }
 
             return 0.0f;
@@ -867,8 +865,8 @@ struct VSTPluginInstance     : public AudioPluginInstance,
             {
                 const ScopedLock sl (pluginInstance.lock);
 
-                if (effect->getParameter (effect, getParameterIndex()) != newValue)
-                    effect->setParameter (effect, getParameterIndex(), newValue);
+                if (effect->getParameterValueFunction (effect, getParameterIndex()) != newValue)
+                    effect->setParameterValueFunction (effect, getParameterIndex(), newValue);
             }
         }
 
@@ -901,7 +899,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
             if (valueType != nullptr || ! vstValueStrings.isEmpty())
                 return getText (getValue(), 1024);
 
-            return pluginInstance.getTextForOpcode (getParameterIndex(), Vst2::effGetParamDisplay);
+            return pluginInstance.getTextForOpcode (getParameterIndex(), Vst2::plugInOpcodeGetParameterText);
         }
 
         float getDefaultValue() const override
@@ -913,7 +911,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
         {
             if (name.isEmpty())
                 return pluginInstance.getTextForOpcode (getParameterIndex(),
-                                                        Vst2::effGetParamName);
+                                                        Vst2::plugInOpcodeGetParameterName);
 
             if (name.length() <= maximumStringLength)
                 return name;
@@ -933,7 +931,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
         String getLabel() const override
         {
             return label.isEmpty() ? pluginInstance.getTextForOpcode (getParameterIndex(),
-                                                                      Vst2::effGetParamLabel)
+                                                                      Vst2::plugInOpcodeGetParameterLabel)
                                    : label;
         }
 
@@ -975,7 +973,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
         const VSTXMLInfo::ValueType* const valueType;
     };
 
-    VSTPluginInstance (const ModuleHandle::Ptr& mh, const BusesProperties& ioConfig, Vst2::AEffect* effect,
+    VSTPluginInstance (const ModuleHandle::Ptr& mh, const BusesProperties& ioConfig, Vst2::VstEffectInterface* effect,
                        double sampleRateToUse, int blockSizeToUse)
         : AudioPluginInstance (ioConfig),
           vstEffect (effect),
@@ -998,13 +996,13 @@ struct VSTPluginInstance     : public AudioPluginInstance,
     {
         AudioProcessorParameterGroup newParameterTree;
 
-        for (int i = 0; i < vstEffect->numParams; ++i)
+        for (int i = 0; i < vstEffect->numParameters; ++i)
         {
             String paramName;
             Array<String> shortParamNames;
             float defaultValue = 0;
             String label;
-            bool isAutomatable = dispatch (Vst2::effCanBeAutomated, i, 0, nullptr, 0) != 0;
+            bool isAutomatable = dispatch (Vst2::plugInOpcodeIsParameterAutomatable, i, 0, nullptr, 0) != 0;
             bool isDiscrete = false;
             int numSteps = AudioProcessor::getDefaultNumParameterSteps();
             bool isBoolSwitch = false;
@@ -1072,7 +1070,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
 
     ~VSTPluginInstance() override
     {
-        if (vstEffect != nullptr && vstEffect->magic == 0x56737450 /* 'VstP' */)
+        if (vstEffect != nullptr && vstEffect->interfaceIdentifier == Vst2::juceVstInterfaceIdentifier)
         {
             struct VSTDeleter : public CallbackMessage
             {
@@ -1105,7 +1103,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
 
     void cleanup()
     {
-        if (vstEffect != nullptr && vstEffect->magic == 0x56737450 /* 'VstP' */)
+        if (vstEffect != nullptr && vstEffect->interfaceIdentifier == Vst2::juceVstInterfaceIdentifier)
         {
            #if JUCE_MAC
             if (vstModule->resFileId != 0)
@@ -1130,16 +1128,16 @@ struct VSTPluginInstance     : public AudioPluginInstance,
     {
         if (auto* newEffect = constructEffect (newModule))
         {
-            newEffect->resvd2 = 0;
+            newEffect->hostSpace2 = 0;
 
-            newEffect->dispatcher (newEffect, Vst2::effIdentify, 0, 0, nullptr, 0);
+            newEffect->dispatchFunction (newEffect, Vst2::plugInOpcodeIdentify, 0, 0, nullptr, 0);
 
             auto blockSize = jmax (32, initialBlockSize);
 
-            newEffect->dispatcher (newEffect, Vst2::effSetSampleRate, 0, 0, nullptr, static_cast<float> (initialSampleRate));
-            newEffect->dispatcher (newEffect, Vst2::effSetBlockSize,  0, blockSize, nullptr, 0);
+            newEffect->dispatchFunction (newEffect, Vst2::plugInOpcodeSetSampleRate, 0, 0, nullptr, static_cast<float> (initialSampleRate));
+            newEffect->dispatchFunction (newEffect, Vst2::plugInOpcodeSetBlockSize,  0, blockSize, nullptr, 0);
 
-            newEffect->dispatcher (newEffect, Vst2::effOpen, 0, 0, nullptr, 0);
+            newEffect->dispatchFunction (newEffect, Vst2::plugInOpcodeOpen, 0, 0, nullptr, 0);
             BusesProperties ioConfig = queryBusIO (newEffect);
 
             return new VSTPluginInstance (newModule, ioConfig, newEffect, initialSampleRate, blockSize);
@@ -1155,7 +1153,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
 
         {
             char buffer[512] = { 0 };
-            dispatch (Vst2::effGetEffectName, 0, 0, buffer, 0);
+            dispatch (Vst2::plugInOpcodeGetPlugInName, 0, 0, buffer, 0);
 
             desc.descriptiveName = String::createStringFromData (buffer, (int) sizeof (buffer)).trim();
 
@@ -1172,7 +1170,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
 
         {
             char buffer[512] = { 0 };
-            dispatch (Vst2::effGetVendorString, 0, 0, buffer, 0);
+            dispatch (Vst2::plugInOpcodeGetManufacturerName, 0, 0, buffer, 0);
             desc.manufacturerName = String::createStringFromData (buffer, (int) sizeof (buffer)).trim();
         }
 
@@ -1186,7 +1184,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
     {
         if (vstEffect != nullptr)
         {
-            vstEffect->resvd2 = (pointer_sized_int) (pointer_sized_int) this;
+            vstEffect->hostSpace2 = (pointer_sized_int) (pointer_sized_int) this;
             initialise (initialSampleRate, initialBlockSize);
             return true;
         }
@@ -1212,25 +1210,25 @@ struct VSTPluginInstance     : public AudioPluginInstance,
 
         setRateAndBufferSizeDetails (initialSampleRate, initialBlockSize);
 
-        dispatch (Vst2::effIdentify, 0, 0, nullptr, 0);
+        dispatch (Vst2::plugInOpcodeIdentify, 0, 0, nullptr, 0);
 
         if (getSampleRate() > 0)
-            dispatch (Vst2::effSetSampleRate, 0, 0, nullptr, (float) getSampleRate());
+            dispatch (Vst2::plugInOpcodeSetSampleRate, 0, 0, nullptr, (float) getSampleRate());
 
         if (getBlockSize() > 0)
-            dispatch (Vst2::effSetBlockSize, 0, jmax (32, getBlockSize()), nullptr, 0);
+            dispatch (Vst2::plugInOpcodeSetBlockSize, 0, jmax (32, getBlockSize()), nullptr, 0);
 
-        dispatch (Vst2::effOpen, 0, 0, nullptr, 0);
+        dispatch (Vst2::plugInOpcodeOpen, 0, 0, nullptr, 0);
 
         setRateAndBufferSizeDetails (getSampleRate(), getBlockSize());
 
         if (getNumPrograms() > 1)
             setCurrentProgram (0);
         else
-            dispatch (Vst2::effSetProgram, 0, 0, nullptr, 0);
+            dispatch (Vst2::plugInOpcodeSetCurrentProgram, 0, 0, nullptr, 0);
 
-        for (int i = vstEffect->numInputs;  --i >= 0;)  dispatch (Vst2::effConnectInput,  i, 1, nullptr, 0);
-        for (int i = vstEffect->numOutputs; --i >= 0;)  dispatch (Vst2::effConnectOutput, i, 1, nullptr, 0);
+        for (int i = vstEffect->numInputChannels;  --i >= 0;)  dispatch (Vst2::plugInOpcodeConnectInput,  i, 1, nullptr, 0);
+        for (int i = vstEffect->numOutputChannels; --i >= 0;)  dispatch (Vst2::plugInOpcodeConnectOutput, i, 1, nullptr, 0);
 
         if (getVstCategory() != Vst2::kPlugCategShell) // (workaround for Waves 5 plugins which crash during this call)
             updateStoredProgramNames();
@@ -1241,7 +1239,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
         usesCocoaNSView = ((unsigned int) pluginCanDo ("hasCockosViewAsConfig") & 0xffff0000ul) == 0xbeef0000ul;
        #endif
 
-        setLatencySamples (vstEffect->initialDelay);
+        setLatencySamples (vstEffect->latency);
     }
 
     void* getPlatformSpecificData() override    { return vstEffect; }
@@ -1252,7 +1250,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
         {
             char buffer[512] = { 0 };
 
-            if (dispatch (Vst2::effGetProductString, 0, 0, buffer, 0) != 0)
+            if (dispatch (Vst2::plugInOpcodeGetManufacturerProductName, 0, 0, buffer, 0) != 0)
             {
                 String productName = String::createStringFromData (buffer, (int) sizeof (buffer));
 
@@ -1266,7 +1264,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
 
     int getUID() const
     {
-        int uid = vstEffect != nullptr ? vstEffect->uniqueID : 0;
+        int uid = vstEffect != nullptr ? vstEffect->plugInIdentifier : 0;
 
         if (uid == 0)
             uid = vstModule->file.hashCode();
@@ -1279,10 +1277,10 @@ struct VSTPluginInstance     : public AudioPluginInstance,
         if (vstEffect == nullptr)
             return 0.0;
 
-        if ((vstEffect->flags & Vst2::effFlagsNoSoundInStop) != 0)
+        if ((vstEffect->flags & 512) != 0)
             return 0.0;
 
-        auto tailSize = dispatch (Vst2::effGetTailSize, 0, 0, nullptr, 0);
+        auto tailSize = dispatch (Vst2::plugInOpcodeGetTailSize, 0, 0, nullptr, 0);
         auto sampleRate = getSampleRate();
 
         // remain backward compatible with old JUCE plug-ins: anything larger
@@ -1302,11 +1300,11 @@ struct VSTPluginInstance     : public AudioPluginInstance,
     bool producesMidi() const override   { return pluginCanDo ("sendVstMidiEvent") > 0; }
     bool supportsMPE() const override    { return pluginCanDo ("MPE") > 0; }
 
-    Vst2::VstPlugCategory getVstCategory() const noexcept     { return (Vst2::VstPlugCategory) dispatch (Vst2::effGetPlugCategory, 0, 0, nullptr, 0); }
+    Vst2::VstPlugInCategory getVstCategory() const noexcept     { return (Vst2::VstPlugInCategory) dispatch (Vst2::plugInOpcodeGetPlugInCategory, 0, 0, nullptr, 0); }
 
-    bool isSynthPlugin() const  { return (vstEffect != nullptr && (vstEffect->flags & Vst2::effFlagsIsSynth) != 0); }
+    bool isSynthPlugin() const  { return (vstEffect != nullptr && (vstEffect->flags & Vst2::vstEffectFlagIsSynth) != 0); }
 
-    int pluginCanDo (const char* text) const  { return (int) dispatch (Vst2::effCanDo, 0, 0, (void*) text,  0); }
+    int pluginCanDo (const char* text) const  { return (int) dispatch (Vst2::plugInOpcodeCanPlugInDo, 0, 0, (void*) text,  0); }
 
     //==============================================================================
     void prepareToPlay (double rate, int samplesPerBlockExpected) override
@@ -1321,17 +1319,17 @@ struct VSTPluginInstance     : public AudioPluginInstance,
             SpeakerMappings::VstSpeakerConfigurationHolder inArr  (getChannelLayoutOfBus (true,  0));
             SpeakerMappings::VstSpeakerConfigurationHolder outArr (getChannelLayoutOfBus (false, 0));
 
-            dispatch (Vst2::effSetSpeakerArrangement, 0, (pointer_sized_int) &inArr.get(), (void*) &outArr.get(), 0.0f);
+            dispatch (Vst2::plugInOpcodeSetSpeakerConfiguration, 0, (pointer_sized_int) &inArr.get(), (void*) &outArr.get(), 0.0f);
         }
 
-        vstHostTime.tempo = 120.0;
-        vstHostTime.timeSigNumerator = 4;
-        vstHostTime.timeSigDenominator = 4;
+        vstHostTime.tempoBPM = 120.0;
+        vstHostTime.timeSignatureNumerator = 4;
+        vstHostTime.timeSignatureDenominator = 4;
         vstHostTime.sampleRate = rate;
-        vstHostTime.samplePos = 0;
-        vstHostTime.flags = Vst2::kVstNanosValid
-                              | Vst2::kVstAutomationWriting
-                              | Vst2::kVstAutomationReading;
+        vstHostTime.samplePosition = 0;
+        vstHostTime.flags = Vst2::vstTimingInfoFlagNanosecondsValid
+                              | Vst2::vstTimingInfoFlagAutomationWriteModeActive
+                              | Vst2::vstTimingInfoFlagAutomationReadModeActive;
 
         initialise (rate, samplesPerBlockExpected);
 
@@ -1346,18 +1344,18 @@ struct VSTPluginInstance     : public AudioPluginInstance,
 
             incomingMidi.clear();
 
-            dispatch (Vst2::effSetSampleRate, 0, 0, nullptr, (float) rate);
-            dispatch (Vst2::effSetBlockSize, 0, jmax (16, samplesPerBlockExpected), nullptr, 0);
+            dispatch (Vst2::plugInOpcodeSetSampleRate, 0, 0, nullptr, (float) rate);
+            dispatch (Vst2::plugInOpcodeSetBlockSize, 0, jmax (16, samplesPerBlockExpected), nullptr, 0);
 
             if (supportsDoublePrecisionProcessing())
             {
-                int32 vstPrecision = isUsingDoublePrecision() ? Vst2::kVstProcessPrecision64
-                                                              : Vst2::kVstProcessPrecision32;
+                int32 vstPrecision = isUsingDoublePrecision() ? Vst2::vstProcessingSampleTypeDouble
+                                                              : Vst2::vstProcessingSampleTypeFloat;
 
-                dispatch (Vst2::effSetProcessPrecision, 0, (pointer_sized_int) vstPrecision, nullptr, 0);
+                dispatch (Vst2::plugInOpcodeSetSampleFloatType, 0, (pointer_sized_int) vstPrecision, nullptr, 0);
             }
 
-            auto maxChannels = jmax (1, jmax (vstEffect->numInputs, vstEffect->numOutputs));
+            auto maxChannels = jmax (1, jmax (vstEffect->numInputChannels, vstEffect->numOutputChannels));
 
             tmpBufferFloat .setSize (maxChannels, samplesPerBlockExpected);
             tmpBufferDouble.setSize (maxChannels, samplesPerBlockExpected);
@@ -1365,7 +1363,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
             channelBufferFloat .calloc (static_cast<size_t> (maxChannels));
             channelBufferDouble.calloc (static_cast<size_t> (maxChannels));
 
-            outOfPlaceBuffer.setSize (jmax (1, vstEffect->numOutputs), samplesPerBlockExpected);
+            outOfPlaceBuffer.setSize (jmax (1, vstEffect->numOutputChannels), samplesPerBlockExpected);
 
             if (! isPowerOn)
                 setPower (true);
@@ -1381,9 +1379,9 @@ struct VSTPluginInstance     : public AudioPluginInstance,
                 }
             }
 
-            dispatch (Vst2::effStartProcess, 0, 0, nullptr, 0);
+            dispatch (Vst2::plugInOpcodeStartProcess, 0, 0, nullptr, 0);
 
-            setLatencySamples (vstEffect->initialDelay);
+            setLatencySamples (vstEffect->latency);
         }
     }
 
@@ -1391,7 +1389,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
     {
         if (initialised)
         {
-            dispatch (Vst2::effStopProcess, 0, 0, nullptr, 0);
+            dispatch (Vst2::plugInOpcodeStopProcess, 0, 0, nullptr, 0);
             setPower (false);
         }
 
@@ -1444,8 +1442,8 @@ struct VSTPluginInstance     : public AudioPluginInstance,
     //==============================================================================
     bool supportsDoublePrecisionProcessing() const override
     {
-        return ((vstEffect->flags & Vst2::effFlagsCanReplacing) != 0
-             && (vstEffect->flags & Vst2::effFlagsCanDoubleReplacing) != 0);
+        return ((vstEffect->flags & Vst2::vstEffectFlagInplaceAudio) != 0
+             && (vstEffect->flags & Vst2::vstEffectFlagInplaceDoubleAudio) != 0);
     }
 
     AudioProcessorParameter* getBypassParameter() const override               { return vstSupportsBypass ? bypassParam.get() : nullptr; }
@@ -1463,15 +1461,15 @@ struct VSTPluginInstance     : public AudioPluginInstance,
         if (numInputBuses > 1 || numOutputBuses > 1)
             return (layouts == getBusesLayout());
 
-        return (layouts.getNumChannels (true,  0) <= vstEffect->numInputs
-             && layouts.getNumChannels (false, 0) <= vstEffect->numOutputs);
+        return (layouts.getNumChannels (true,  0) <= vstEffect->numInputChannels
+             && layouts.getNumChannels (false, 0) <= vstEffect->numOutputChannels);
     }
 
     //==============================================================================
    #if JUCE_IOS || JUCE_ANDROID
     bool hasEditor() const override                  { return false; }
    #else
-    bool hasEditor() const override                  { return vstEffect != nullptr && (vstEffect->flags & Vst2::effFlagsHasEditor) != 0; }
+    bool hasEditor() const override                  { return vstEffect != nullptr && (vstEffect->flags & Vst2::vstEffectFlagHasEditor) != 0; }
    #endif
 
     AudioProcessorEditor* createEditor() override;
@@ -1481,9 +1479,9 @@ struct VSTPluginInstance     : public AudioPluginInstance,
     {
         if (isValidChannel (index, true))
         {
-            Vst2::VstPinProperties pinProps;
-            if (dispatch (Vst2::effGetInputProperties, index, 0, &pinProps, 0.0f) != 0)
-                return String (pinProps.label, sizeof (pinProps.label));
+            Vst2::VstPinInfo pinProps;
+            if (dispatch (Vst2::plugInOpcodeGetInputPinProperties, index, 0, &pinProps, 0.0f) != 0)
+                return String (pinProps.text, sizeof (pinProps.text));
         }
 
         return {};
@@ -1494,9 +1492,9 @@ struct VSTPluginInstance     : public AudioPluginInstance,
         if (! isValidChannel (index, true))
             return false;
 
-        Vst2::VstPinProperties pinProps;
-        if (dispatch (Vst2::effGetInputProperties, index, 0, &pinProps, 0.0f) != 0)
-            return (pinProps.flags & Vst2::kVstPinIsStereo) != 0;
+        Vst2::VstPinInfo pinProps;
+        if (dispatch (Vst2::plugInOpcodeGetInputPinProperties, index, 0, &pinProps, 0.0f) != 0)
+            return (pinProps.flags & Vst2::vstPinInfoFlagIsStereo) != 0;
 
         return true;
     }
@@ -1505,9 +1503,9 @@ struct VSTPluginInstance     : public AudioPluginInstance,
     {
         if (isValidChannel (index, false))
         {
-            Vst2::VstPinProperties pinProps;
-            if (dispatch (Vst2::effGetOutputProperties, index, 0, &pinProps, 0.0f) != 0)
-                return String (pinProps.label, sizeof (pinProps.label));
+            Vst2::VstPinInfo pinProps;
+            if (dispatch (Vst2::plugInOpcodeGetOutputPinProperties, index, 0, &pinProps, 0.0f) != 0)
+                return String (pinProps.text, sizeof (pinProps.text));
         }
 
         return {};
@@ -1518,9 +1516,9 @@ struct VSTPluginInstance     : public AudioPluginInstance,
         if (! isValidChannel (index, false))
             return false;
 
-        Vst2::VstPinProperties pinProps;
-        if (dispatch (Vst2::effGetOutputProperties, index, 0, &pinProps, 0.0f) != 0)
-            return (pinProps.flags & Vst2::kVstPinIsStereo) != 0;
+        Vst2::VstPinInfo pinProps;
+        if (dispatch (Vst2::plugInOpcodeGetOutputPinProperties, index, 0, &pinProps, 0.0f) != 0)
+            return (pinProps.flags & Vst2::vstPinInfoFlagIsStereo) != 0;
 
         return true;
     }
@@ -1535,12 +1533,12 @@ struct VSTPluginInstance     : public AudioPluginInstance,
     int getNumPrograms() override          { return vstEffect != nullptr ? jmax (0, vstEffect->numPrograms) : 0; }
 
     // NB: some plugs return negative numbers from this function.
-    int getCurrentProgram() override       { return (int) dispatch (Vst2::effGetProgram, 0, 0, nullptr, 0); }
+    int getCurrentProgram() override       { return (int) dispatch (Vst2::plugInOpcodeGetCurrentProgram, 0, 0, 0, 0); }
 
     void setCurrentProgram (int newIndex) override
     {
         if (getNumPrograms() > 0 && newIndex != getCurrentProgram())
-            dispatch (Vst2::effSetProgram, 0, jlimit (0, getNumPrograms() - 1, newIndex), nullptr, 0);
+            dispatch (Vst2::plugInOpcodeSetCurrentProgram, 0, jlimit (0, getNumPrograms() - 1, newIndex), 0, 0);
     }
 
     const String getProgramName (int index) override
@@ -1554,7 +1552,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
             {
                 char nm[264] = { 0 };
 
-                if (dispatch (Vst2::effGetProgramNameIndexed, jlimit (0, getNumPrograms(), index), -1, nm, 0) != 0)
+                if (dispatch (Vst2::plugInOpcodeGetProgramName, jlimit (0, getNumPrograms(), index), -1, nm, 0) != 0)
                     return String::fromUTF8 (nm).trim();
             }
         }
@@ -1567,7 +1565,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
         if (index >= 0 && index == getCurrentProgram())
         {
             if (getNumPrograms() > 0 && newName != getCurrentProgramName())
-                dispatch (Vst2::effSetProgramName, 0, 0, (void*) newName.substring (0, 24).toRawUTF8(), 0.0f);
+                dispatch (Vst2::plugInOpcodeSetCurrentProgramName, 0, 0, (void*) newName.substring (0, 24).toRawUTF8(), 0.0f);
         }
         else
         {
@@ -1585,7 +1583,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
     //==============================================================================
     void timerCallback() override
     {
-        if (dispatch (Vst2::effIdle, 0, 0, nullptr, 0) == 0)
+        if (dispatch (Vst2::plugInOpcodeIdle, 0, 0, nullptr, 0) == 0)
             stopTimer();
     }
 
@@ -1599,7 +1597,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
     {
         switch (opcode)
         {
-            case Vst2::audioMasterAutomate:
+            case Vst2::hostOpcodeParameterChanged:
                 if (auto* param = getParameters()[index])
                     param->sendValueChangedMessageToListeners (opt);
                 else
@@ -1607,23 +1605,23 @@ struct VSTPluginInstance     : public AudioPluginInstance,
 
                 break;
 
-            case Vst2::audioMasterProcessEvents:            handleMidiFromPlugin ((const Vst2::VstEvents*) ptr); break;
-            case Vst2::audioMasterGetTime:                  return getVSTTime();
-            case Vst2::audioMasterIdle:                     handleIdle(); break;
-            case Vst2::audioMasterSizeWindow:               setWindowSize (index, (int) value); return 1;
-            case Vst2::audioMasterUpdateDisplay:            triggerAsyncUpdate(); break;
-            case Vst2::audioMasterIOChanged:                setLatencySamples (vstEffect->initialDelay); break;
-            case Vst2::audioMasterNeedIdle:                 startTimer (50); break;
+            case Vst2::hostOpcodePreAudioProcessingEvents:    handleMidiFromPlugin ((const Vst2::VstEventBlock*) ptr); break;
+            case Vst2::hostOpcodeGetTimingInfo:               return getVSTTime();
+            case Vst2::hostOpcodeIdle:                        handleIdle(); break;
+            case Vst2::hostOpcodeWindowSize:                  setWindowSize (index, (int) value); return 1;
+            case Vst2::hostOpcodeUpdateView:                  triggerAsyncUpdate(); break;
+            case Vst2::hostOpcodeIOModified:                  setLatencySamples (vstEffect->latency); break;
+            case Vst2::hostOpcodeNeedsIdle:                   startTimer (50); break;
 
-            case Vst2::audioMasterGetSampleRate:            return (pointer_sized_int) (getSampleRate() > 0 ? getSampleRate() : defaultVSTSampleRateValue);
-            case Vst2::audioMasterGetBlockSize:             return (pointer_sized_int) (getBlockSize() > 0  ? getBlockSize()  : defaultVSTBlockSizeValue);
-            case Vst2::audioMasterWantMidi:                 wantsMidiMessages = true; break;
-            case Vst2::audioMasterGetDirectory:             return getVstDirectory();
+            case Vst2::hostOpcodeGetSampleRate:               return (pointer_sized_int) (getSampleRate() > 0 ? getSampleRate() : defaultVSTSampleRateValue);
+            case Vst2::hostOpcodeGetBlockSize:                return (pointer_sized_int) (getBlockSize() > 0  ? getBlockSize()  : defaultVSTBlockSizeValue);
+            case Vst2::hostOpcodePlugInWantsMidi:             wantsMidiMessages = true; break;
+            case Vst2::hostOpcodeGetDirectory:                return getVstDirectory();
 
-            case Vst2::audioMasterTempoAt:                  return (pointer_sized_int) (extraFunctions != nullptr ? extraFunctions->getTempoAt ((int64) value) : 0);
-            case Vst2::audioMasterGetAutomationState:       return (pointer_sized_int) (extraFunctions != nullptr ? extraFunctions->getAutomationState() : 0);
+            case Vst2::hostOpcodeTempoAt:                     return (pointer_sized_int) (extraFunctions != nullptr ? extraFunctions->getTempoAt ((int64) value) : 0);
+            case Vst2::hostOpcodeGetAutomationState:          return (pointer_sized_int) (extraFunctions != nullptr ? extraFunctions->getAutomationState() : 0);
 
-            case Vst2::audioMasterBeginEdit:
+            case Vst2::hostOpcodeParameterChangeGestureBegin:
                 if (auto* param = getParameters()[index])
                     param->beginChangeGesture();
                 else
@@ -1631,7 +1629,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
 
                 break;
 
-            case Vst2::audioMasterEndEdit:
+            case Vst2::hostOpcodeParameterChangeGestureEnd:
                 if (auto* param = getParameters()[index])
                     param->endChangeGesture();
                 else
@@ -1639,28 +1637,28 @@ struct VSTPluginInstance     : public AudioPluginInstance,
 
                 break;
 
-            case Vst2::audioMasterPinConnected:             return isValidChannel (index, value == 0) ? 0 : 1; // (yes, 0 = true)
-            case Vst2::audioMasterGetCurrentProcessLevel:   return isNonRealtime() ? 4 : 0;
+            case Vst2::hostOpcodePinConnected:                   return isValidChannel (index, value == 0) ? 0 : 1; // (yes, 0 = true)
+            case Vst2::hostOpcodeGetCurrentAudioProcessingLevel: return isNonRealtime() ? 4 : 0;
 
             // none of these are handled (yet)...
-            case Vst2::audioMasterSetTime:
-            case Vst2::audioMasterGetParameterQuantization:
-            case Vst2::audioMasterGetInputLatency:
-            case Vst2::audioMasterGetOutputLatency:
-            case Vst2::audioMasterGetPreviousPlug:
-            case Vst2::audioMasterGetNextPlug:
-            case Vst2::audioMasterWillReplaceOrAccumulate:
-            case Vst2::audioMasterOfflineStart:
-            case Vst2::audioMasterOfflineRead:
-            case Vst2::audioMasterOfflineWrite:
-            case Vst2::audioMasterOfflineGetCurrentPass:
-            case Vst2::audioMasterOfflineGetCurrentMetaPass:
-            case Vst2::audioMasterGetOutputSpeakerArrangement:
-            case Vst2::audioMasterVendorSpecific:
-            case Vst2::audioMasterSetIcon:
-            case Vst2::audioMasterGetLanguage:
-            case Vst2::audioMasterOpenWindow:
-            case Vst2::audioMasterCloseWindow:
+            case Vst2::hostOpcodeSetTime:
+            case Vst2::hostOpcodeGetParameterInterval:
+            case Vst2::hostOpcodeGetInputLatency:
+            case Vst2::hostOpcodeGetOutputLatency:
+            case Vst2::hostOpcodeGetPreviousPlugIn:
+            case Vst2::hostOpcodeGetNextPlugIn:
+            case Vst2::hostOpcodeWillReplace:
+            case Vst2::hostOpcodeOfflineStart:
+            case Vst2::hostOpcodeOfflineReadSource:
+            case Vst2::hostOpcodeOfflineWrite:
+            case Vst2::hostOpcodeOfflineGetCurrentPass:
+            case Vst2::hostOpcodeOfflineGetCurrentMetaPass:
+            case Vst2::hostOpcodeGetOutputSpeakerConfiguration:
+            case Vst2::hostOpcodeManufacturerSpecific:
+            case Vst2::hostOpcodeSetIcon:
+            case Vst2::hostOpcodeGetLanguage:
+            case Vst2::hostOpcodeOpenEditorWindow:
+            case Vst2::hostOpcodeCloseEditorWindow:
                 break;
 
             default:
@@ -1675,19 +1673,19 @@ struct VSTPluginInstance     : public AudioPluginInstance,
     {
         switch (opcode)
         {
-            case Vst2::audioMasterCanDo:                        return handleCanDo ((const char*) ptr);
-            case Vst2::audioMasterVersion:                      return 2400;
-            case Vst2::audioMasterCurrentId:                    return shellUIDToCreate;
-            case Vst2::audioMasterGetNumAutomatableParameters:  return 0;
-            case Vst2::audioMasterGetAutomationState:           return 1;
-            case Vst2::audioMasterGetVendorVersion:             return 0x0101;
+            case Vst2::hostOpcodeCanHostDo:                         return handleCanDo ((const char*) ptr);
+            case Vst2::hostOpcodeVstVersion:                        return 2400;
+            case Vst2::hostOpcodeCurrentId:                         return shellUIDToCreate;
+            case Vst2::hostOpcodeGetNumberOfAutomatableParameters:  return 0;
+            case Vst2::hostOpcodeGetAutomationState:                return 1;
+            case Vst2::hostOpcodeGetManufacturerVersion:            return 0x0101;
 
-            case Vst2::audioMasterGetVendorString:
-            case Vst2::audioMasterGetProductString:             return getHostName ((char*) ptr);
+            case Vst2::hostOpcodeGetManufacturerName:
+            case Vst2::hostOpcodeGetProductName:                    return getHostName ((char*) ptr);
 
-            case Vst2::audioMasterGetSampleRate:                return (pointer_sized_int) defaultVSTSampleRateValue;
-            case Vst2::audioMasterGetBlockSize:                 return (pointer_sized_int) defaultVSTBlockSizeValue;
-            case Vst2::audioMasterSetOutputSampleRate:          return 0;
+            case Vst2::hostOpcodeGetSampleRate:                     return (pointer_sized_int) defaultVSTSampleRateValue;
+            case Vst2::hostOpcodeGetBlockSize:                      return (pointer_sized_int) defaultVSTBlockSizeValue;
+            case Vst2::hostOpcodeSetOutputSampleRate:               return 0;
 
             default:
                 DBG ("*** Unhandled VST Callback: " + String ((int) opcode));
@@ -1716,7 +1714,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
                     UseResFile (vstModule->resFileId);
                #endif
 
-                result = vstEffect->dispatcher (vstEffect, opcode, index, value, ptr, opt);
+                result = vstEffect->dispatchFunction (vstEffect, opcode, index, value, ptr, opt);
 
                #if JUCE_MAC
                 auto newResFile = CurResFile();
@@ -1922,14 +1920,14 @@ struct VSTPluginInstance     : public AudioPluginInstance,
         return true;
     }
 
-    bool usesChunks() const noexcept        { return vstEffect != nullptr && (vstEffect->flags & Vst2::effFlagsProgramChunks) != 0; }
+    bool usesChunks() const noexcept        { return vstEffect != nullptr && (vstEffect->flags & Vst2::vstEffectFlagDataInChunks) != 0; }
 
     bool getChunkData (MemoryBlock& mb, bool isPreset, int maxSizeMB) const
     {
         if (usesChunks())
         {
             void* data = nullptr;
-            auto bytes = (size_t) dispatch (Vst2::effGetChunk, isPreset ? 1 : 0, 0, &data, 0.0f);
+            auto bytes = (size_t) dispatch (Vst2::plugInOpcodeGetData, isPreset ? 1 : 0, 0, &data, 0.0f);
 
             if (data != nullptr && bytes <= (size_t) maxSizeMB * 1024 * 1024)
             {
@@ -1947,7 +1945,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
     {
         if (size > 0 && usesChunks())
         {
-            dispatch (Vst2::effSetChunk, isPreset ? 1 : 0, size, (void*) data, 0.0f);
+            dispatch (Vst2::plugInOpcodeSetData, isPreset ? 1 : 0, size, (void*) data, 0.0f);
 
             if (! isPreset)
                 updateStoredProgramNames();
@@ -1958,7 +1956,7 @@ struct VSTPluginInstance     : public AudioPluginInstance,
         return false;
     }
 
-    Vst2::AEffect* vstEffect;
+    Vst2::VstEffectInterface* vstEffect;
     ModuleHandle::Ptr vstModule;
 
     std::unique_ptr<VSTPluginFormat::ExtraFunctions> extraFunctions;
@@ -1981,7 +1979,7 @@ private:
             currentValue = (newValue != 0.0f);
 
             if (parent.vstSupportsBypass)
-                parent.dispatch (Vst2::effSetBypass, 0, currentValue ? 1 : 0, nullptr, 0.0f);
+                parent.dispatch (Vst2::plugInOpcodeSetBypass, 0, currentValue ? 1 : 0, nullptr, 0.0f);
         }
 
         float getValueForText (const String& text) const override
@@ -2028,7 +2026,7 @@ private:
     CriticalSection midiInLock;
     MidiBuffer incomingMidi;
     VSTMidiEventList midiEventsToSend;
-    Vst2::VstTimeInfo vstHostTime;
+    Vst2::VstTimingInformation vstHostTime;
 
     AudioBuffer<float> tmpBufferFloat;
     HeapBlock<float*> channelBufferFloat;
@@ -2065,7 +2063,7 @@ private:
         if (auto* app = JUCEApplicationBase::getInstance())
             hostName = app->getApplicationName();
 
-        hostName.copyToUTF8 (name, (size_t) jmin (Vst2::kVstMaxVendorStrLen, Vst2::kVstMaxProductStrLen) - 1);
+        hostName.copyToUTF8 (name, (size_t) jmin (Vst2::vstMaxManufacturerStringLength, Vst2::vstMaxPlugInNameStringLength) - 1);
         return 1;
     }
 
@@ -2086,7 +2084,7 @@ private:
 
            #if JUCE_MAC
             if (getActiveEditor() != nullptr)
-                dispatch (Vst2::effEditIdle, 0, 0, nullptr, 0);
+                dispatch (Vst2::plugInOpcodeEditorIdle, 0, 0, nullptr, 0);
            #endif
 
             Timer::callPendingTimersSynchronously();
@@ -2121,9 +2119,9 @@ private:
     }
 
     //==============================================================================
-    static Vst2::AEffect* constructEffect (const ModuleHandle::Ptr& module)
+    static Vst2::VstEffectInterface* constructEffect (const ModuleHandle::Ptr& module)
     {
-        Vst2::AEffect* effect = nullptr;
+        Vst2::VstEffectInterface* effect = nullptr;
         try
         {
             const IdleCallRecursionPreventer icrp;
@@ -2140,10 +2138,10 @@ private:
                 JUCE_VST_WRAPPER_INVOKE_MAIN
             }
 
-            if (effect != nullptr && effect->magic == 0x56737450 /* 'VstP' */)
+            if (effect != nullptr && effect->interfaceIdentifier == Vst2::juceVstInterfaceIdentifier)
             {
-                jassert (effect->resvd2 == 0);
-                jassert (effect->object != nullptr);
+                jassert (effect->hostSpace2 == 0);
+                jassert (effect->effectPointer != 0);
 
                 _fpreset(); // some dodgy plugs mess around with this
             }
@@ -2158,11 +2156,11 @@ private:
         return effect;
     }
 
-    static BusesProperties queryBusIO (Vst2::AEffect* effect)
+    static BusesProperties queryBusIO (Vst2::VstEffectInterface* effect)
     {
         BusesProperties returnValue;
 
-        if (effect->numInputs == 0 && effect->numOutputs == 0)
+        if (effect->numInputChannels == 0 && effect->numOutputChannels == 0)
             return returnValue;
 
         // Workaround for old broken JUCE plug-ins which would return an invalid
@@ -2173,14 +2171,14 @@ private:
         // plug-in is reporting.
         if (! pluginHasDefaultChannelLayouts (effect))
         {
-            SpeakerMappings::VstSpeakerConfigurationHolder canonicalIn  (AudioChannelSet::canonicalChannelSet (effect->numInputs));
-            SpeakerMappings::VstSpeakerConfigurationHolder canonicalOut (AudioChannelSet::canonicalChannelSet (effect->numOutputs));
+            SpeakerMappings::VstSpeakerConfigurationHolder canonicalIn  (AudioChannelSet::canonicalChannelSet (effect->numInputChannels));
+            SpeakerMappings::VstSpeakerConfigurationHolder canonicalOut (AudioChannelSet::canonicalChannelSet (effect->numOutputChannels));
 
-            effect->dispatcher (effect, Vst2::effSetSpeakerArrangement, 0,
+            effect->dispatchFunction (effect, Vst2::plugInOpcodeSetSpeakerConfiguration, 0,
                                       (pointer_sized_int) &canonicalIn.get(), (void*) &canonicalOut.get(), 0.0f);
         }
 
-        HeapBlock<Vst2::VstSpeakerArrangement> inArrBlock (1, true), outArrBlock (1, true);
+        HeapBlock<Vst2::VstSpeakerConfiguration> inArrBlock (1, true), outArrBlock (1, true);
 
         auto* inArr  = inArrBlock.get();
         auto* outArr = outArrBlock.get();
@@ -2191,35 +2189,35 @@ private:
         for (int dir = 0; dir < 2; ++dir)
         {
             const bool isInput = (dir == 0);
-            const int opcode = (isInput ? Vst2::effGetInputProperties : Vst2::effGetOutputProperties);
-            const int maxChannels = (isInput ? effect->numInputs : effect->numOutputs);
-            const Vst2::VstSpeakerArrangement* arr = (isInput ? inArr : outArr);
+            const int opcode = (isInput ? Vst2::plugInOpcodeGetInputPinProperties : Vst2::plugInOpcodeGetOutputPinProperties);
+            const int maxChannels = (isInput ? effect->numInputChannels : effect->numOutputChannels);
+            const Vst2::VstSpeakerConfiguration* arr = (isInput ? inArr : outArr);
             bool busAdded = false;
 
-            Vst2::VstPinProperties pinProps;
+            Vst2::VstPinInfo pinProps;
             AudioChannelSet layout;
 
             for (int ch = 0; ch < maxChannels; ch += layout.size())
             {
-                if (effect->dispatcher (effect, opcode, ch, 0, &pinProps, 0.0f) == 0)
+                if (effect->dispatchFunction (effect, opcode, ch, 0, &pinProps, 0.0f) == 0)
                     break;
 
-                if ((pinProps.flags & Vst2::kVstPinUseSpeaker) != 0)
+                if ((pinProps.flags & Vst2::vstPinInfoFlagValid) != 0)
                 {
-                    layout = SpeakerMappings::vstArrangementTypeToChannelSet (pinProps.arrangementType, 0);
+                    layout = SpeakerMappings::vstArrangementTypeToChannelSet (pinProps.configurationType, 0);
 
                     if (layout.isDisabled())
                         break;
                 }
                 else if (arr == nullptr)
                 {
-                    layout = ((pinProps.flags & Vst2::kVstPinIsStereo) != 0 ? AudioChannelSet::stereo() : AudioChannelSet::mono());
+                    layout = ((pinProps.flags & Vst2::vstPinInfoFlagIsStereo) != 0 ? AudioChannelSet::stereo() : AudioChannelSet::mono());
                 }
                 else
                     break;
 
                 busAdded = true;
-                returnValue.addBus (isInput, pinProps.label, layout, true);
+                returnValue.addBus (isInput, pinProps.text, layout, true);
             }
 
             // no buses?
@@ -2227,8 +2225,8 @@ private:
             {
                 String busName = (isInput ? "Input" : "Output");
 
-                if (effect->dispatcher (effect, opcode, 0, 0, &pinProps, 0.0f) != 0)
-                    busName = pinProps.label;
+                if (effect->dispatchFunction (effect, opcode, 0, 0, &pinProps, 0.0f) != 0)
+                    busName = pinProps.text;
 
                 if (arr != nullptr)
                     layout = SpeakerMappings::vstArrangementTypeToChannelSet (*arr);
@@ -2242,9 +2240,9 @@ private:
         return returnValue;
     }
 
-    static bool pluginHasDefaultChannelLayouts (Vst2::AEffect* effect)
+    static bool pluginHasDefaultChannelLayouts (Vst2::VstEffectInterface* effect)
     {
-        HeapBlock<Vst2::VstSpeakerArrangement> inArrBlock (1, true), outArrBlock (1, true);
+        HeapBlock<Vst2::VstSpeakerConfiguration> inArrBlock (1, true), outArrBlock (1, true);
 
         auto* inArr  = inArrBlock.get();
         auto* outArr = outArrBlock.get();
@@ -2255,40 +2253,40 @@ private:
         for (int dir = 0; dir < 2; ++dir)
         {
             const bool isInput = (dir == 0);
-            const int opcode = (isInput ? Vst2::effGetInputProperties : Vst2::effGetOutputProperties);
-            const int maxChannels = (isInput ? effect->numInputs : effect->numOutputs);
+            const int opcode = (isInput ? Vst2::plugInOpcodeGetInputPinProperties : Vst2::plugInOpcodeGetOutputPinProperties);
+            const int maxChannels = (isInput ? effect->numInputChannels : effect->numOutputChannels);
 
             int channels = 1;
 
             for (int ch = 0; ch < maxChannels; ch += channels)
             {
-                Vst2::VstPinProperties pinProps;
+                Vst2::VstPinInfo pinProps;
 
-                if (effect->dispatcher (effect, opcode, ch, 0, &pinProps, 0.0f) == 0)
+                if (effect->dispatchFunction (effect, opcode, ch, 0, &pinProps, 0.0f) == 0)
                     return false;
 
-                if ((pinProps.flags & Vst2::kVstPinUseSpeaker) != 0)
+                if ((pinProps.flags & Vst2::vstPinInfoFlagValid) != 0)
                     return true;
 
-                channels = (pinProps.flags & Vst2::kVstPinIsStereo) != 0 ? 2 : 1;
+                channels = (pinProps.flags & Vst2::vstPinInfoFlagIsStereo) != 0 ? 2 : 1;
             }
         }
 
         return false;
     }
 
-    static bool getSpeakerArrangementWrapper (Vst2::AEffect* effect,
-                                              Vst2::VstSpeakerArrangement* inArr,
-                                              Vst2::VstSpeakerArrangement* outArr)
+    static bool getSpeakerArrangementWrapper (Vst2::VstEffectInterface* effect,
+                                              Vst2::VstSpeakerConfiguration* inArr,
+                                              Vst2::VstSpeakerConfiguration* outArr)
     {
         // Workaround: unfortunately old JUCE VST-2 plug-ins had a bug and would crash if
         // you try to get the speaker arrangement when there are no input channels present.
         // Hopefully, one day (when there are no more old JUCE plug-ins around), we can
         // comment out the next two lines.
-        if (effect->numInputs == 0)
+        if (effect->numInputChannels == 0)
             return false;
 
-        return (effect->dispatcher (effect, Vst2::effGetSpeakerArrangement, 0,
+        return (effect->dispatchFunction (effect, Vst2::plugInOpcodeGetSpeakerArrangement, 0,
                                           reinterpret_cast<pointer_sized_int> (&inArr), &outArr, 0.0f) != 0);
     }
 
@@ -2322,57 +2320,57 @@ private:
                 if (currentPlayHead->getCurrentPosition (position))
                 {
 
-                    vstHostTime.samplePos          = (double) position.timeInSamples;
-                    vstHostTime.tempo              = position.bpm;
-                    vstHostTime.timeSigNumerator   = position.timeSigNumerator;
-                    vstHostTime.timeSigDenominator = position.timeSigDenominator;
-                    vstHostTime.ppqPos             = position.ppqPosition;
-                    vstHostTime.barStartPos        = position.ppqPositionOfLastBarStart;
-                    vstHostTime.flags |= Vst2::kVstTempoValid
-                                           | Vst2::kVstTimeSigValid
-                                           | Vst2::kVstPpqPosValid
-                                           | Vst2::kVstBarsValid;
+                    vstHostTime.samplePosition           = (double) position.timeInSamples;
+                    vstHostTime.tempoBPM                 = position.bpm;
+                    vstHostTime.timeSignatureNumerator   = position.timeSigNumerator;
+                    vstHostTime.timeSignatureDenominator = position.timeSigDenominator;
+                    vstHostTime.musicalPosition          = position.ppqPosition;
+                    vstHostTime.lastBarPosition          = position.ppqPositionOfLastBarStart;
+                    vstHostTime.flags |= Vst2::vstTimingInfoFlagTempoValid
+                                           | Vst2::vstTimingInfoFlagTimeSignatureValid
+                                           | Vst2::vstTimingInfoFlagMusicalPositionValid
+                                           | Vst2::vstTimingInfoFlagLastBarPositionValid;
 
                     int32 newTransportFlags = 0;
-                    if (position.isPlaying)     newTransportFlags |= Vst2::kVstTransportPlaying;
-                    if (position.isRecording)   newTransportFlags |= Vst2::kVstTransportRecording;
+                    if (position.isPlaying)     newTransportFlags |= Vst2::vstTimingInfoFlagCurrentlyPlaying;
+                    if (position.isRecording)   newTransportFlags |= Vst2::vstTimingInfoFlagCurrentlyRecording;
 
-                    if (newTransportFlags != (vstHostTime.flags & (Vst2::kVstTransportPlaying
-                                                                   | Vst2::kVstTransportRecording)))
-                        vstHostTime.flags = (vstHostTime.flags & ~(Vst2::kVstTransportPlaying | Vst2::kVstTransportRecording)) | newTransportFlags | Vst2::kVstTransportChanged;
+                    if (newTransportFlags != (vstHostTime.flags & (Vst2::vstTimingInfoFlagCurrentlyPlaying
+                                                                   | Vst2::vstTimingInfoFlagCurrentlyRecording)))
+                        vstHostTime.flags = (vstHostTime.flags & ~(Vst2::vstTimingInfoFlagCurrentlyPlaying | Vst2::vstTimingInfoFlagCurrentlyRecording)) | newTransportFlags | Vst2::vstTimingInfoFlagTransportChanged;
                     else
-                        vstHostTime.flags &= ~Vst2::kVstTransportChanged;
+                        vstHostTime.flags &= ~Vst2::vstTimingInfoFlagTransportChanged;
 
                     switch (position.frameRate)
                     {
-                        case AudioPlayHead::fps24:       setHostTimeFrameRate (Vst2::kVstSmpte24fps, 24.0, position.timeInSeconds); break;
-                        case AudioPlayHead::fps25:       setHostTimeFrameRate (Vst2::kVstSmpte25fps, 25.0, position.timeInSeconds); break;
-                        case AudioPlayHead::fps30:       setHostTimeFrameRate (Vst2::kVstSmpte30fps, 30.0, position.timeInSeconds); break;
-                        case AudioPlayHead::fps60:       setHostTimeFrameRate (Vst2::kVstSmpte60fps, 60.0, position.timeInSeconds); break;
-
-                        case AudioPlayHead::fps23976:    setHostTimeFrameRateDrop (Vst2::kVstSmpte239fps,   24.0, position.timeInSeconds); break;
-                        case AudioPlayHead::fps2997:     setHostTimeFrameRateDrop (Vst2::kVstSmpte2997fps,  30.0, position.timeInSeconds); break;
-                        case AudioPlayHead::fps2997drop: setHostTimeFrameRateDrop (Vst2::kVstSmpte2997dfps, 30.0, position.timeInSeconds); break;
-                        case AudioPlayHead::fps30drop:   setHostTimeFrameRateDrop (Vst2::kVstSmpte30dfps,   30.0, position.timeInSeconds); break;
-                        case AudioPlayHead::fps60drop:   setHostTimeFrameRateDrop (Vst2::kVstSmpte599fps,   60.0, position.timeInSeconds); break;
+                        case AudioPlayHead::fps24:       setHostTimeFrameRate (Vst2::vstSmpteRateFps24, 24.0, position.timeInSeconds); break;
+                        case AudioPlayHead::fps25:       setHostTimeFrameRate (Vst2::vstSmpteRateFps25, 25.0, position.timeInSeconds); break;
+                        case AudioPlayHead::fps30:       setHostTimeFrameRate (Vst2::vstSmpteRateFps30, 30.0, position.timeInSeconds); break;
+                        case AudioPlayHead::fps60:       setHostTimeFrameRate (Vst2::vstSmpteRateFps60, 60.0, position.timeInSeconds); break;
+
+                        case AudioPlayHead::fps23976:    setHostTimeFrameRateDrop (Vst2::vstSmpteRateFps239,      24.0, position.timeInSeconds); break;
+                        case AudioPlayHead::fps2997:     setHostTimeFrameRateDrop (Vst2::vstSmpteRateFps2997,     30.0, position.timeInSeconds); break;
+                        case AudioPlayHead::fps2997drop: setHostTimeFrameRateDrop (Vst2::vstSmpteRateFps2997drop, 30.0, position.timeInSeconds); break;
+                        case AudioPlayHead::fps30drop:   setHostTimeFrameRateDrop (Vst2::vstSmpteRateFps30drop,   30.0, position.timeInSeconds); break;
+                        case AudioPlayHead::fps60drop:   setHostTimeFrameRateDrop (Vst2::vstSmpteRateFps599,      60.0, position.timeInSeconds); break;
                         case AudioPlayHead::fpsUnknown:
                         default: break;
                     }
 
                     if (position.isLooping)
                     {
-                        vstHostTime.cycleStartPos = position.ppqLoopStart;
-                        vstHostTime.cycleEndPos   = position.ppqLoopEnd;
-                        vstHostTime.flags |= (Vst2::kVstCyclePosValid | Vst2::kVstTransportCycleActive);
+                        vstHostTime.loopStartPosition = position.ppqLoopStart;
+                        vstHostTime.loopEndPosition   = position.ppqLoopEnd;
+                        vstHostTime.flags |= (Vst2::vstTimingInfoFlagLoopPositionValid | Vst2::vstTimingInfoFlagLoopActive);
                     }
                     else
                     {
-                        vstHostTime.flags &= ~(Vst2::kVstCyclePosValid | Vst2::kVstTransportCycleActive);
+                        vstHostTime.flags &= ~(Vst2::vstTimingInfoFlagLoopPositionValid | Vst2::vstTimingInfoFlagLoopActive);
                     }
                 }
             }
 
-            vstHostTime.nanoSeconds = getVSTHostTimeNanoseconds();
+            vstHostTime.systemTimeNanoseconds = getVSTHostTimeNanoseconds();
 
             if (wantsMidiMessages)
             {
@@ -2383,13 +2381,13 @@ private:
                     midiEventsToSend.addEvent (metadata.data, metadata.numBytes,
                                                jlimit (0, numSamples - 1, metadata.samplePosition));
 
-                vstEffect->dispatcher (vstEffect, Vst2::effProcessEvents, 0, 0, midiEventsToSend.events, 0);
+                vstEffect->dispatchFunction (vstEffect, Vst2::plugInOpcodePreAudioProcessingEvents, 0, 0, midiEventsToSend.events, 0);
             }
 
             _clearfp();
 
             // always ensure that the buffer is at least as large as the maximum number of channels
-            auto maxChannels = jmax (vstEffect->numInputs, vstEffect->numOutputs);
+            auto maxChannels = jmax (vstEffect->numInputChannels, vstEffect->numOutputChannels);
             auto channels = channelBuffer.get();
 
             if (numChannels < maxChannels)
@@ -2428,35 +2426,35 @@ private:
     //==============================================================================
     inline void invokeProcessFunction (AudioBuffer<float>& buffer, int32 sampleFrames)
     {
-        if ((vstEffect->flags & Vst2::effFlagsCanReplacing) != 0)
+        if ((vstEffect->flags & Vst2::vstEffectFlagInplaceAudio) != 0)
         {
-            vstEffect->processReplacing (vstEffect, buffer.getArrayOfWritePointers(),
+            vstEffect->processAudioInplaceFunction (vstEffect, buffer.getArrayOfWritePointers(),
                                                     buffer.getArrayOfWritePointers(), sampleFrames);
         }
         else
         {
-            outOfPlaceBuffer.setSize (vstEffect->numOutputs, sampleFrames);
+            outOfPlaceBuffer.setSize (vstEffect->numOutputChannels, sampleFrames);
             outOfPlaceBuffer.clear();
 
-            vstEffect->process (vstEffect, buffer.getArrayOfWritePointers(),
-                                           outOfPlaceBuffer.getArrayOfWritePointers(), sampleFrames);
+            vstEffect->processAudioFunction (vstEffect, buffer.getArrayOfWritePointers(),
+                                             outOfPlaceBuffer.getArrayOfWritePointers(), sampleFrames);
 
-            for (int i = vstEffect->numOutputs; --i >= 0;)
+            for (int i = vstEffect->numOutputChannels; --i >= 0;)
                 buffer.copyFrom (i, 0, outOfPlaceBuffer.getReadPointer (i), sampleFrames);
         }
     }
 
     inline void invokeProcessFunction (AudioBuffer<double>& buffer, int32 sampleFrames)
     {
-        vstEffect->processDoubleReplacing (vstEffect, buffer.getArrayOfWritePointers(),
+        vstEffect->processDoubleAudioInplaceFunction (vstEffect, buffer.getArrayOfWritePointers(),
                                                       buffer.getArrayOfWritePointers(), sampleFrames);
     }
 
     //==============================================================================
     void setHostTimeFrameRate (long frameRateIndex, double frameRate, double currentTime) noexcept
     {
-        vstHostTime.flags |= Vst2::kVstSmpteValid;
-        vstHostTime.smpteFrameRate   = (int32) frameRateIndex;
+        vstHostTime.flags |= Vst2::vstTimingInfoFlagSmpteValid;
+        vstHostTime.smpteRate   = (int32) frameRateIndex;
         vstHostTime.smpteOffset = (int32) (currentTime * 80.0 * frameRate + 0.5);
     }
 
@@ -2487,7 +2485,7 @@ private:
         if (vstEffect == nullptr)
             return {};
 
-        jassert (index >= 0 && index < vstEffect->numParams);
+        jassert (index >= 0 && index < vstEffect->numParameters);
         char nm[256] = { 0 };
         dispatch (opcode, index, 0, nm, 0);
         return String::createStringFromData (nm, (int) sizeof (nm)).trim();
@@ -2501,7 +2499,7 @@ private:
         {
             {
                 char nm[256] = { 0 };
-                dispatch (Vst2::effGetProgramName, 0, 0, nm, 0);
+                dispatch (Vst2::plugInOpcodeGetCurrentProgramName, 0, 0, nm, 0);
                 progName = String::createStringFromData (nm, (int) sizeof (nm)).trim();
             }
 
@@ -2545,7 +2543,7 @@ private:
             char nm[256] = { 0 };
 
             // only do this if the plugin can't use indexed names..
-            if (dispatch (Vst2::effGetProgramNameIndexed, 0, -1, nm, 0) == 0)
+            if (dispatch (Vst2::plugInOpcodeGetProgramName, 0, -1, nm, 0) == 0)
             {
                 auto oldProgram = getCurrentProgram();
                 MemoryBlock oldSettings;
@@ -2563,7 +2561,7 @@ private:
         }
     }
 
-    void handleMidiFromPlugin (const Vst2::VstEvents* events)
+    void handleMidiFromPlugin (const Vst2::VstEventBlock* events)
     {
         if (events != nullptr)
         {
@@ -2610,11 +2608,11 @@ private:
     }
 
     //==============================================================================
-    int getVersionNumber() const noexcept   { return vstEffect != nullptr ? vstEffect->version : 0; }
+    int getVersionNumber() const noexcept   { return vstEffect != nullptr ? vstEffect->plugInVersion : 0; }
 
     String getVersion() const
     {
-        auto v = (unsigned int) dispatch (Vst2::effGetVendorVersion, 0, 0, nullptr, 0);
+        auto v = (unsigned int) dispatch (Vst2::plugInOpcodeGetManufacturerVersion, 0, 0, nullptr, 0);
 
         String s;
 
@@ -2682,7 +2680,6 @@ private:
             case Vst2::kPlugCategOfflineProcess:  return "Offline Process";
             case Vst2::kPlugCategShell:           return "Shell";
             case Vst2::kPlugCategUnknown:         return "Unknown";
-            case Vst2::kPlugCategMaxCount:
             default:                              break;
         }
 
@@ -2691,7 +2688,7 @@ private:
 
     void setPower (const bool on)
     {
-        dispatch (Vst2::effMainsChanged, 0, on ? 1 : 0, nullptr, 0);
+        dispatch (Vst2::plugInOpcodeResumeSuspend, 0, on ? 1 : 0, nullptr, 0);
         isPowerOn = on;
     }
 
@@ -2758,11 +2755,11 @@ public:
 
         activeVSTWindows.add (this);
 
-        Vst2::ERect* rect = nullptr;
-        dispatch (Vst2::effEditGetRect, 0, 0, &rect, 0);
+        Vst2::VstEditorBounds* rect = nullptr;
+        dispatch (Vst2::plugInOpcodeGetEditorBounds, 0, 0, &rect, 0);
 
         if (rect != nullptr)
-            setSize (rect->right - rect->left, rect->bottom - rect->top);
+            setSize (rect->rightmost - rect->leftmost, rect->lower - rect->upper);
         else
             setSize (1, 1);
 
@@ -2928,7 +2925,7 @@ public:
         nativeScaleFactor = (float) newScaleFactor;
 
         if (pluginRespondsToDPIChanges)
-            dispatch (Vst2::effVendorSpecific,
+            dispatch (Vst2::plugInOpcodeManufacturerSpecific,
                       JUCE_MULTICHAR_CONSTANT ('P', 'r', 'e', 'S'),
                       JUCE_MULTICHAR_CONSTANT ('A', 'e', 'C', 's'),
                       nullptr, nativeScaleFactor);
@@ -2957,7 +2954,7 @@ public:
             if (! reentrantGuard)
             {
                 reentrantGuard = true;
-                plugin.dispatch (Vst2::effEditIdle, 0, 0, nullptr, 0);
+                plugin.dispatch (Vst2::plugInOpcodeEditorIdle, 0, 0, nullptr, 0);
                 reentrantGuard = false;
             }
 
@@ -2989,7 +2986,7 @@ public:
         activeVSTWindows.add (this);
 
        #if JUCE_MAC
-        dispatch (Vst2::effEditTop, 0, 0, nullptr, 0);
+        dispatch (Vst2::plugInOpcodeeffEditorTop, 0, 0, nullptr, 0);
        #endif
     }
 
@@ -3019,24 +3016,24 @@ private:
 
         isOpen = true;
 
-        Vst2::ERect* rect = nullptr;
-        dispatch (Vst2::effEditGetRect, 0, 0, &rect, 0);
-        dispatch (Vst2::effEditOpen, 0, 0, parentWindow, 0);
+        Vst2::VstEditorBounds* rect = nullptr;
+        dispatch (Vst2::plugInOpcodeGetEditorBounds, 0, 0, &rect, 0);
+        dispatch (Vst2::plugInOpcodeOpenEditor, 0, 0, parentWindow, 0);
 
         // do this before and after like in the steinberg example
-        dispatch (Vst2::effEditGetRect, 0, 0, &rect, 0);
-        dispatch (Vst2::effGetProgram, 0, 0, nullptr, 0); // also in steinberg code
+        dispatch (Vst2::plugInOpcodeGetEditorBounds, 0, 0, &rect, 0);
+        dispatch (Vst2::plugInOpcodeGetCurrentProgram, 0, 0, nullptr, 0); // also in steinberg code
 
         // Install keyboard hooks
-        pluginWantsKeys = (dispatch (Vst2::effKeysRequired, 0, 0, nullptr, 0) == 0);
+        pluginWantsKeys = (dispatch (Vst2::plugInOpcodeKeyboardFocusRequired, 0, 0, nullptr, 0) == 0);
 
         // double-check it's not too tiny
         int w = 250, h = 150;
 
         if (rect != nullptr)
         {
-            w = rect->right - rect->left;
-            h = rect->bottom - rect->top;
+            w = rect->rightmost - rect->leftmost;
+            h = rect->lower - rect->upper;
 
             if (w == 0 || h == 0)
             {
@@ -3067,14 +3064,14 @@ private:
         if (auto* peer = getTopLevelComponent()->getPeer())
             setScaleFactorAndDispatchMessage (peer->getPlatformScaleFactor());
 
-        Vst2::ERect* rect = nullptr;
+        Vst2::VstEditorBounds* rect = nullptr;
 
-        dispatch (Vst2::effEditGetRect, 0, 0, &rect, 0);
-        dispatch (Vst2::effEditOpen, 0, 0, getWindowHandle(), 0);
-        dispatch (Vst2::effEditGetRect, 0, 0, &rect, 0);  // do this before and after like in the steinberg example
-        dispatch (Vst2::effGetProgram, 0, 0, nullptr, 0); // also in steinberg code
+        dispatch (Vst2::plugInOpcodeGetEditorBounds, 0, 0, &rect, 0);
+        dispatch (Vst2::plugInOpcodeOpenEditor, 0, 0, getWindowHandle(), 0);
+        dispatch (Vst2::plugInOpcodeGetEditorBounds, 0, 0, &rect, 0);  // do this before and after like in the steinberg example
+        dispatch (Vst2::plugInOpcodeGetCurrentProgram, 0, 0, nullptr, 0); // also in steinberg code
 
-        pluginWantsKeys = (dispatch (Vst2::effKeysRequired, 0, 0, nullptr, 0) == 0);
+        pluginWantsKeys = (dispatch (Vst2::plugInOpcodeKeyboardFocusRequired, 0, 0, nullptr, 0) == 0);
 
        #if JUCE_WINDOWS
         originalWndProc = 0;
@@ -3104,8 +3101,8 @@ private:
 
         if (rect != nullptr)
         {
-            auto rw = rect->right - rect->left;
-            auto rh = rect->bottom - rect->top;
+            auto rw = rect->rightmost - rect->leftmost;
+            auto rh = rect->lower - rect->upper;
 
             if ((rw > 50 && rh > 50 && rw < 2000 && rh < 2000 && (! isWithin (w, rw, 2) || ! isWithin (h, rh, 2)))
                 || ((w == 0 && rw > 0) || (h == 0 && rh > 0)))
@@ -3140,8 +3137,8 @@ private:
 
         if (rect != nullptr)
         {
-            w = rect->right - rect->left;
-            h = rect->bottom - rect->top;
+            w = rect->rightmost - rect->leftmost;
+            h = rect->lower - rect->upper;
 
             if (w == 0 || h == 0)
             {
@@ -3190,7 +3187,7 @@ private:
 
             JUCE_VST_LOG ("Closing VST UI: " + plugin.getName());
             isOpen = false;
-            dispatch (Vst2::effEditClose, 0, 0, nullptr, 0);
+            dispatch (Vst2::plugInOpcodeCloseEditor, 0, 0, nullptr, 0);
             stopTimer();
 
            #if JUCE_WINDOWS
@@ -3233,11 +3230,11 @@ private:
     {
         if (! pluginRespondsToDPIChanges)
         {
-            Vst2::ERect* rect = nullptr;
-            dispatch (Vst2::effEditGetRect, 0, 0, &rect, 0);
+            Vst2::VstEditorBounds* rect = nullptr;
+            dispatch (Vst2::plugInOpcodeGetEditorBounds, 0, 0, &rect, 0);
 
-            auto w = roundToInt ((rect->right - rect->left) / nativeScaleFactor);
-            auto h = roundToInt ((rect->bottom - rect->top) / nativeScaleFactor);
+            auto w = roundToInt ((rect->rightmost - rect->leftmost) / nativeScaleFactor);
+            auto h = roundToInt ((rect->lower - rect->upper) / nativeScaleFactor);
 
             if (! isWindowSizeCorrectForPlugin (w, h))
             {
@@ -3323,8 +3320,8 @@ private:
 
           bool getEmbeddedViewSize (int& w, int& h) override
           {
-              Vst2::ERect* rect = nullptr;
-              owner.dispatch (Vst2::effEditGetRect, 0, 0, &rect, 0);
+              Vst2::VstEditorBounds* rect = nullptr;
+              owner.dispatch (Vst2::plugInOpcodeGetEditorBounds, 0, 0, &rect, 0);
               w = rect->right - rect->left;
               h = rect->bottom - rect->top;
               return true;
@@ -3350,7 +3347,7 @@ private:
               if (auto* peer = getPeer())
               {
                   auto pos = peer->globalToLocal (getScreenPosition());
-                  Vst2::ERect r;
+                  Vst2::VstEditorBounds r;
                   r.left   = (int16) pos.getX();
                   r.top    = (int16) pos.getY();
                   r.right  = (int16) (r.left + getWidth());
@@ -3423,10 +3420,10 @@ AudioProcessorEditor* VSTPluginInstance::createEditor()
 
 //==============================================================================
 // entry point for all callbacks from the plugin
-static pointer_sized_int VSTCALLBACK audioMaster (Vst2::AEffect* effect, int32 opcode, int32 index, pointer_sized_int value, void* ptr, float opt)
+static pointer_sized_int VSTINTERFACECALL audioMaster (Vst2::VstEffectInterface* effect, int32 opcode, int32 index, pointer_sized_int value, void* ptr, float opt)
 {
     if (effect != nullptr)
-        if (auto* instance = (VSTPluginInstance*) (effect->resvd2))
+        if (auto* instance = (VSTPluginInstance*) (effect->hostSpace2))
             return instance->handleCallback (opcode, index, value, ptr, opt);
 
     return VSTPluginInstance::handleGeneralCallback (opcode, index, value, ptr, opt);
@@ -3477,7 +3474,7 @@ void VSTPluginFormat::findAllTypesForFile (OwnedArray<PluginDescription>& result
         // Normal plugin...
         results.add (new PluginDescription (desc));
 
-        instance->dispatch (Vst2::effOpen, 0, 0, nullptr, 0);
+        instance->dispatch (Vst2::plugInOpcodeOpen, 0, 0, nullptr, 0);
     }
     else
     {
@@ -3485,7 +3482,7 @@ void VSTPluginFormat::findAllTypesForFile (OwnedArray<PluginDescription>& result
         for (;;)
         {
             char shellEffectName [256] = { 0 };
-            auto uid = (int) instance->dispatch (Vst2::effShellGetNextPlugin, 0, 0, shellEffectName, 0);
+            auto uid = (int) instance->dispatch (Vst2::plugInOpcodeNextPlugInUniqueID, 0, 0, shellEffectName, 0);
 
             if (uid == 0)
                 break;
@@ -3709,8 +3706,8 @@ void VSTPluginFormat::setExtraFunctions (AudioPluginInstance* plugin, ExtraFunct
 
 AudioPluginInstance* VSTPluginFormat::getPluginInstanceFromVstEffectInterface (void* aEffect)
 {
-    if (auto* vstAEffect = reinterpret_cast<Vst2::AEffect*> (aEffect))
-        if (auto* instanceVST = reinterpret_cast<VSTPluginInstance*> (vstAEffect->resvd2))
+    if (auto* vstAEffect = reinterpret_cast<Vst2::VstEffectInterface*> (aEffect))
+        if (auto* instanceVST = reinterpret_cast<VSTPluginInstance*> (vstAEffect->hostSpace2))
             return dynamic_cast<AudioPluginInstance*> (instanceVST);
 
     return nullptr;
